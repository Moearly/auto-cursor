# 08 - åç«¯æ¶æ„

## ğŸ“‹ æ¶æ„æ¦‚è¿°

Auto-Cursor åç«¯é‡‡ç”¨ Rust + Tauri 2.0 æ„å»ºï¼Œæä¾›é«˜æ€§èƒ½çš„ç³»ç»Ÿçº§æ“ä½œå’Œæ•°æ®åº“ç®¡ç†èƒ½åŠ›ã€‚

## ğŸ—ï¸ æ¨¡å—ç»“æ„

```
src-tauri/src/
â”œâ”€â”€ main.rs              # åº”ç”¨å…¥å£
â”œâ”€â”€ lib.rs               # Tauriå‘½ä»¤æ³¨å†Œä¸­å¿ƒï¼ˆ37869è¡Œï¼‰
â”œâ”€â”€ machine_id.rs        # æœºå™¨IDç®¡ç†æ¨¡å—ï¼ˆ1694è¡Œï¼‰
â”œâ”€â”€ account_manager.rs   # è´¦å·ç®¡ç†æ¨¡å—ï¼ˆ1428è¡Œï¼‰
â”œâ”€â”€ auth_checker.rs      # è®¤è¯æ£€æŸ¥æ¨¡å—ï¼ˆ2061è¡Œï¼‰
â””â”€â”€ logger.rs            # æ—¥å¿—ç³»ç»Ÿæ¨¡å—
```

## ğŸ“¦ æ ¸å¿ƒæ¨¡å—

### 1. lib.rs - å‘½ä»¤æ³¨å†Œä¸­å¿ƒ

è¿™æ˜¯æ•´ä¸ªåç«¯çš„æ ¸å¿ƒï¼Œè´Ÿè´£æ³¨å†Œæ‰€æœ‰ Tauri å‘½ä»¤å¹¶åˆå§‹åŒ–åº”ç”¨ã€‚

```rust
#[cfg_attr(mobile, tauri::mobile_entry_point)]
pub fn run() {
    tauri::Builder::default()
        // æ’ä»¶æ³¨å†Œ
        .plugin(tauri_plugin_opener::init())
        .plugin(tauri_plugin_fs::init())
        .plugin(tauri_plugin_dialog::init())
        
        // å‘½ä»¤æ³¨å†Œ
        .invoke_handler(tauri::generate_handler![
            // ========== æœºå™¨IDç®¡ç† ==========
            check_cursor_installation,
            get_cursor_paths,
            find_backups,
            extract_ids_from_backup,
            create_backup,
            reset_machine_ids,
            complete_cursor_reset,
            get_current_machine_ids,
            get_machine_id_file_content,
            get_backup_directory_info,
            
            // ========== è´¦å·ç®¡ç† ==========
            list_accounts,
            switch_account,
            switch_account_with_token,
            add_account,
            delete_account,
            logout_account,
            get_current_account,
            
            // ========== è®¤è¯æ£€æŸ¥ ==========
            check_cursor_auth,
            get_usage_stats,
            get_aggregated_usage,
            get_user_analytics,
            
            // ========== è‡ªåŠ¨æ³¨å†Œ ==========
            register_cursor_account,
            register_cursor_account_with_config,
            register_cursor_account_batch,
            input_verification_code_for_registration,
            
            // ========== è™šæ‹Ÿå¡ç”Ÿæˆ ==========
            generate_virtual_card,
            save_bank_card_config,
            load_bank_card_config,
            list_bank_card_configs,
            delete_bank_card_config,
            
            // ========== é‚®ç®±é…ç½® ==========
            save_email_config,
            load_email_config,
            
            // ========== ç³»ç»Ÿå·¥å…· ==========
            debug_windows_cursor_paths,
            set_custom_cursor_path,
            get_custom_cursor_path,
            clear_custom_cursor_path,
            test_logging,
            
            // ========== æ›´æ–°æ£€æŸ¥ ==========
            check_for_updates,
        ])
        
        .run(tauri::generate_context!())
        .expect("error while running tauri application");
}
```

### 2. machine_id.rs - æœºå™¨IDç®¡ç†

è´Ÿè´£ Cursor æœºå™¨æ ‡è¯†çš„ç”Ÿæˆã€å¤‡ä»½ã€æ¢å¤å’Œç³»ç»Ÿçº§æ›´æ–°ã€‚

#### æ ¸å¿ƒç»“æ„

```rust
pub struct MachineIdRestorer {
    pub db_path: PathBuf,           // storage.json è·¯å¾„
    pub sqlite_path: PathBuf,       // state.vscdb è·¯å¾„
    pub log_file_path: PathBuf,     // æ—¥å¿—æ–‡ä»¶è·¯å¾„
}

impl MachineIdRestorer {
    // åˆ›å»ºå®ä¾‹
    pub fn new() -> Result<Self> {
        let (db_path, sqlite_path) = Self::get_cursor_paths()?;
        let timestamp = chrono::Local::now().format("%Y%m%d_%H%M%S").to_string();
        let log_file_path = std::env::current_dir()?
            .join(format!("cursor_reset_{}.log", timestamp));
        
        Ok(Self {
            db_path,
            sqlite_path,
            log_file_path,
        })
    }
    
    // ç”Ÿæˆæ–°æœºå™¨ID
    pub fn generate_new_machine_ids(&self) -> Result<MachineIds> {
        // UUID v4
        let dev_device_id = Uuid::new_v4().to_string();
        
        // SHA256 (64å­—ç¬¦)
        let mut machine_id_data = [0u8; 32];
        rand::thread_rng().fill(&mut machine_id_data);
        let machine_id = format!("{:x}", Sha256::digest(&machine_id_data));
        
        // SHA512 (128å­—ç¬¦)
        let mut mac_machine_id_data = [0u8; 64];
        rand::thread_rng().fill(&mut mac_machine_id_data);
        let mac_machine_id = format!("{:x}", Sha512::digest(&mac_machine_id_data));
        
        // GUIDæ ¼å¼
        let sqm_id = format!("{{{}}}", Uuid::new_v4().to_string().to_uppercase());
        
        Ok(MachineIds {
            dev_device_id: dev_device_id.clone(),
            mac_machine_id,
            machine_id,
            sqm_id,
            service_machine_id: dev_device_id,
        })
    }
    
    // å®Œæ•´é‡ç½®æµç¨‹
    pub fn complete_cursor_reset(&self) -> Result<ResetResult> {
        // 1. è®°å½•ç³»ç»Ÿä¿¡æ¯
        self.log_system_info();
        
        // 2. åˆ›å»ºå¤‡ä»½
        self.create_backup()?;
        
        // 3. ç”Ÿæˆæ–°ID
        let new_ids = self.generate_new_machine_ids()?;
        
        // 4. æ›´æ–°æ‰€æœ‰é…ç½®
        self.update_storage_file(&new_ids)?;
        self.update_sqlite_db(&new_ids)?;
        self.update_machine_id_file(&new_ids.dev_device_id)?;
        self.update_system_ids(&new_ids)?;
        
        // 5. ä¿®æ”¹JSæ–‡ä»¶
        self.modify_main_js(&main_js_path)?;
        self.modify_workbench_js(&workbench_path)?;
        
        Ok(ResetResult {
            success: true,
            message: "é‡ç½®æˆåŠŸ".to_string(),
            details: vec![],
            new_ids: Some(new_ids),
        })
    }
}
```

#### å¹³å°ç‰¹å®šå®ç°

```rust
// Windows è·¯å¾„
#[cfg(target_os = "windows")]
fn get_cursor_paths() -> Result<(PathBuf, PathBuf)> {
    let appdata = std::env::var("APPDATA")?;
    let db_path = PathBuf::from(&appdata)
        .join("Cursor")
        .join("User")
        .join("globalStorage")
        .join("storage.json");
    let sqlite_path = PathBuf::from(&appdata)
        .join("Cursor")
        .join("User")
        .join("globalStorage")
        .join("state.vscdb");
    Ok((db_path, sqlite_path))
}

// macOS è·¯å¾„
#[cfg(target_os = "macos")]
fn get_cursor_paths() -> Result<(PathBuf, PathBuf)> {
    let home = dirs::home_dir()?;
    let db_path = home
        .join("Library")
        .join("Application Support")
        .join("Cursor")
        .join("User")
        .join("globalStorage")
        .join("storage.json");
    let sqlite_path = home
        .join("Library")
        .join("Application Support")
        .join("Cursor")
        .join("User")
        .join("globalStorage")
        .join("state.vscdb");
    Ok((db_path, sqlite_path))
}

// Linux è·¯å¾„
#[cfg(target_os = "linux")]
fn get_cursor_paths() -> Result<(PathBuf, PathBuf)> {
    let home = dirs::home_dir()?;
    let db_path = home
        .join(".config")
        .join("Cursor")
        .join("User")
        .join("globalStorage")
        .join("storage.json");
    let sqlite_path = home
        .join(".config")
        .join("Cursor")
        .join("User")
        .join("globalStorage")
        .join("state.vscdb");
    Ok((db_path, sqlite_path))
}
```

### 3. account_manager.rs - è´¦å·ç®¡ç†

è´Ÿè´£ Cursor è´¦å·çš„åˆ‡æ¢ã€æ·»åŠ ã€åˆ é™¤å’Œç™»å½•çŠ¶æ€ç®¡ç†ã€‚

#### æ ¸å¿ƒåŠŸèƒ½

```rust
pub struct AccountManager;

impl AccountManager {
    // å¿«é€Ÿåˆ‡æ¢è´¦å·ï¼ˆé‚®ç®±+Tokenï¼‰
    pub fn switch_account_with_token(
        email: String,
        token: String,
        auth_type: Option<String>,
    ) -> Result<SwitchAccountResult> {
        let mut details = Vec::new();
        
        // 1. æ£€æµ‹å¹¶å¼ºåˆ¶å…³é—­ Cursor
        if Self::is_cursor_running() {
            log_info!("æ£€æµ‹åˆ° Cursor æ­£åœ¨è¿è¡Œï¼Œå‡†å¤‡å…³é—­...");
            Self::force_close_cursor()?;
            details.push("å¼ºåˆ¶å…³é—­ Cursor è¿›ç¨‹".to_string());
            std::thread::sleep(std::time::Duration::from_secs(2));
        }
        
        // 2. å¤„ç† Token æ ¼å¼
        let processed_token = if token.contains("%3A%3A") {
            token.split("%3A%3A").nth(1).unwrap_or(&token)
        } else if token.contains("::") {
            token.split("::").nth(1).unwrap_or(&token)
        } else {
            &token
        };
        
        // 3. æ›´æ–°æ•°æ®åº“
        let (_, sqlite_path) = Self::get_cursor_paths()?;
        let conn = Connection::open(&sqlite_path)?;
        let tx = conn.transaction()?;
        
        let auth_type_value = auth_type.unwrap_or_else(|| "Auth_0".to_string());
        
        // æ›´æ–°æ‰€æœ‰å¿…è¦å­—æ®µ
        let fields = vec![
            ("cursorAuth/cachedEmail", &email),
            ("cursor.email", &email),
            ("cursorAuth/accessToken", processed_token),
            ("cursorAuth/refreshToken", processed_token),
            ("cursor.accessToken", processed_token),
            ("cursorAuth/cachedSignUpType", &auth_type_value),
        ];
        
        for (key, value) in fields {
            tx.execute(
                "INSERT OR REPLACE INTO ItemTable (key, value) VALUES (?1, ?2)",
                params![key, value],
            )?;
        }
        
        tx.commit()?;
        
        // 4. ç­‰å¾…æ•°æ®åº“å†™å…¥å®Œæˆ
        std::thread::sleep(std::time::Duration::from_millis(500));
        
        Ok(SwitchAccountResult {
            success: true,
            message: "è´¦å·åˆ‡æ¢æˆåŠŸ".to_string(),
            details,
        })
    }
    
    // æ£€æµ‹ Cursor æ˜¯å¦è¿è¡Œ
    fn is_cursor_running() -> bool {
        #[cfg(target_os = "windows")]
        {
            let output = Command::new("tasklist")
                .args(&["/FI", "IMAGENAME eq Cursor.exe"])
                .output();
            if let Ok(output) = output {
                return String::from_utf8_lossy(&output.stdout).contains("Cursor.exe");
            }
        }
        
        #[cfg(any(target_os = "macos", target_os = "linux"))]
        {
            let output = Command::new("pgrep")
                .arg("-f")
                .arg("Cursor")
                .output();
            if let Ok(output) = output {
                return output.status.success();
            }
        }
        
        false
    }
    
    // å¼ºåˆ¶å…³é—­ Cursor
    fn force_close_cursor() -> Result<()> {
        #[cfg(target_os = "windows")]
        {
            Command::new("taskkill")
                .args(&["/F", "/IM", "Cursor.exe"])
                .output()?;
        }
        
        #[cfg(target_os = "macos")]
        {
            Command::new("pkill")
                .arg("-f")
                .arg("Cursor")
                .output()?;
        }
        
        #[cfg(target_os = "linux")]
        {
            Command::new("pkill")
                .arg("-f")
                .arg("cursor")
                .output()?;
        }
        
        Ok(())
    }
}
```

### 4. auth_checker.rs - è®¤è¯æ£€æŸ¥

è´Ÿè´£æŸ¥è¯¢ Cursor çš„ç™»å½•çŠ¶æ€å’Œä½¿ç”¨ç»Ÿè®¡ã€‚

#### æ ¸å¿ƒåŠŸèƒ½

```rust
pub struct AuthChecker;

impl AuthChecker {
    // æ£€æŸ¥è®¤è¯çŠ¶æ€
    pub async fn check_auth() -> Result<UserAuthInfo> {
        // 1. ä»æ•°æ®åº“è·å– Token
        let token = Self::get_token_from_db()?;
        
        // 2. è°ƒç”¨ API éªŒè¯
        let client = reqwest::Client::new();
        let response = client
            .get("https://api.cursor.sh/api/auth/status")
            .header("Authorization", format!("Bearer {}", token))
            .send()
            .await?;
        
        if response.status().is_success() {
            let auth_data: serde_json::Value = response.json().await?;
            
            Ok(UserAuthInfo {
                is_authorized: true,
                token_valid: true,
                account_info: Some(Self::parse_account_info(&auth_data)),
                // ...
            })
        } else {
            Ok(UserAuthInfo {
                is_authorized: false,
                token_valid: false,
                // ...
            })
        }
    }
    
    // è·å–ä½¿ç”¨ç»Ÿè®¡
    pub async fn get_usage_stats(
        start_date: Option<u64>,
        end_date: Option<u64>,
    ) -> Result<AggregatedUsageData> {
        let token = Self::get_token_from_db()?;
        
        let client = reqwest::Client::new();
        let response = client
            .post("https://api.cursor.sh/api/usage")
            .header("Authorization", format!("Bearer {}", token))
            .json(&serde_json::json!({
                "start_date": start_date.unwrap_or(Self::default_start_date()),
                "end_date": end_date.unwrap_or(Self::default_end_date()),
                "team_id": 0
            }))
            .send()
            .await?;
        
        let usage_data: AggregatedUsageData = response.json().await?;
        Ok(usage_data)
    }
    
    // ä»æ•°æ®åº“è·å– Token
    fn get_token_from_db() -> Result<String> {
        let (_, sqlite_path) = get_cursor_paths()?;
        let conn = Connection::open(&sqlite_path)?;
        
        let token: String = conn.query_row(
            "SELECT value FROM ItemTable WHERE key = 'cursorAuth/accessToken'",
            [],
            |row| row.get(0),
        )?;
        
        Ok(token)
    }
}
```

### 5. logger.rs - æ—¥å¿—ç³»ç»Ÿ

æä¾›ç»Ÿä¸€çš„æ—¥å¿—è®°å½•åŠŸèƒ½ã€‚

```rust
// æ—¥å¿—å®å®šä¹‰
#[macro_export]
macro_rules! log_info {
    ($($arg:tt)*) => {
        println!("[INFO] {}", format!($($arg)*));
    };
}

#[macro_export]
macro_rules! log_warn {
    ($($arg:tt)*) => {
        println!("[WARN] {}", format!($($arg)*));
    };
}

#[macro_export]
macro_rules! log_error {
    ($($arg:tt)*) => {
        eprintln!("[ERROR] {}", format!($($arg)*));
    };
}

#[macro_export]
macro_rules! log_debug {
    ($($arg:tt)*) => {
        #[cfg(debug_assertions)]
        println!("[DEBUG] {}", format!($($arg)*));
    };
}
```

## ğŸ”§ Tauri å‘½ä»¤æ¨¡å¼

### å‘½ä»¤å®šä¹‰

```rust
#[tauri::command]
async fn example_command(
    param1: String,
    param2: Option<i32>,
    app_handle: tauri::AppHandle,
) -> Result<ResponseType, String> {
    log_info!("æ‰§è¡Œå‘½ä»¤: example_command");
    
    // ä¸šåŠ¡é€»è¾‘
    let result = do_something(param1, param2)?;
    
    // å‘é€äº‹ä»¶åˆ°å‰ç«¯
    app_handle.emit("event-name", &result).ok();
    
    Ok(result)
}
```

### é”™è¯¯å¤„ç†

```rust
// ä½¿ç”¨ Result ç±»å‹
#[tauri::command]
fn may_fail() -> Result<String, String> {
    some_operation()
        .map_err(|e| format!("æ“ä½œå¤±è´¥: {}", e))
}

// ä½¿ç”¨ anyhow
use anyhow::{Result, Context};

fn complex_operation() -> Result<Data> {
    let data = read_file()
        .context("è¯»å–æ–‡ä»¶å¤±è´¥")?;
    
    let processed = process_data(data)
        .context("å¤„ç†æ•°æ®å¤±è´¥")?;
    
    Ok(processed)
}
```

## ğŸ“Š æ•°æ®åº“æ“ä½œ

### SQLite äº‹åŠ¡

```rust
use rusqlite::{Connection, params, Transaction};

fn update_multiple_fields(conn: &Connection) -> Result<()> {
    // å¼€å¯äº‹åŠ¡
    let tx = conn.transaction()?;
    
    // æ‰§è¡Œå¤šä¸ªæ“ä½œ
    tx.execute(
        "INSERT OR REPLACE INTO ItemTable (key, value) VALUES (?1, ?2)",
        params!["key1", "value1"],
    )?;
    
    tx.execute(
        "INSERT OR REPLACE INTO ItemTable (key, value) VALUES (?1, ?2)",
        params!["key2", "value2"],
    )?;
    
    // æäº¤äº‹åŠ¡
    tx.commit()?;
    
    Ok(())
}
```

### æŸ¥è¯¢æ“ä½œ

```rust
// æŸ¥è¯¢å•è¡Œ
let value: String = conn.query_row(
    "SELECT value FROM ItemTable WHERE key = ?1",
    params!["some_key"],
    |row| row.get(0),
)?;

// æŸ¥è¯¢å¤šè¡Œ
let mut stmt = conn.prepare("SELECT key, value FROM ItemTable")?;
let rows = stmt.query_map([], |row| {
    Ok((
        row.get::<_, String>(0)?,
        row.get::<_, String>(1)?,
    ))
})?;

for row in rows {
    let (key, value) = row?;
    println!("{}: {}", key, value);
}
```

## ğŸ” å®‰å…¨æ€§

### 1. è¿›ç¨‹éš”ç¦»

```rust
// Windows: åˆ›å»ºéšè—çª—å£
#[cfg(target_os = "windows")]
fn create_hidden_command(program: &str) -> Command {
    use std::os::windows::process::CommandExt;
    const CREATE_NO_WINDOW: u32 = 0x08000000;
    
    let mut cmd = Command::new(program);
    cmd.creation_flags(CREATE_NO_WINDOW);
    cmd
}
```

### 2. æƒé™æ£€æŸ¥

```rust
fn require_admin_permission() -> Result<()> {
    #[cfg(target_os = "windows")]
    {
        // æ£€æŸ¥æ˜¯å¦æœ‰ç®¡ç†å‘˜æƒé™
        if !is_elevated() {
            return Err(anyhow!("éœ€è¦ç®¡ç†å‘˜æƒé™"));
        }
    }
    
    Ok(())
}
```

### 3. æ•°æ®éªŒè¯

```rust
fn validate_email(email: &str) -> Result<()> {
    let email_regex = Regex::new(r"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$")?;
    
    if !email_regex.is_match(email) {
        return Err(anyhow!("æ— æ•ˆçš„é‚®ç®±åœ°å€"));
    }
    
    Ok(())
}

fn validate_token(token: &str) -> Result<()> {
    if token.len() < 100 {
        return Err(anyhow!("Tokené•¿åº¦ä¸è¶³"));
    }
    
    // JWT æ ¼å¼éªŒè¯
    if !token.starts_with("eyJ") {
        return Err(anyhow!("æ— æ•ˆçš„Tokenæ ¼å¼"));
    }
    
    Ok(())
}
```

## ğŸš€ æ€§èƒ½ä¼˜åŒ–

### 1. å¼‚æ­¥æ“ä½œ

```rust
use tokio::task;

#[tauri::command]
async fn async_operation() -> Result<String, String> {
    // å¹¶å‘æ‰§è¡Œå¤šä¸ªä»»åŠ¡
    let (result1, result2) = tokio::join!(
        task::spawn(async { fetch_data_1().await }),
        task::spawn(async { fetch_data_2().await }),
    );
    
    let data1 = result1.map_err(|e| e.to_string())??;
    let data2 = result2.map_err(|e| e.to_string())??;
    
    Ok(format!("{} + {}", data1, data2))
}
```

### 2. ç¼“å­˜æœºåˆ¶

```rust
use std::sync::{Arc, Mutex};
use std::collections::HashMap;

lazy_static! {
    static ref CACHE: Arc<Mutex<HashMap<String, String>>> = 
        Arc::new(Mutex::new(HashMap::new()));
}

fn get_cached_or_fetch(key: &str) -> Result<String> {
    // æ£€æŸ¥ç¼“å­˜
    {
        let cache = CACHE.lock().unwrap();
        if let Some(value) = cache.get(key) {
            return Ok(value.clone());
        }
    }
    
    // è·å–æ•°æ®
    let value = fetch_data(key)?;
    
    // æ›´æ–°ç¼“å­˜
    {
        let mut cache = CACHE.lock().unwrap();
        cache.insert(key.to_string(), value.clone());
    }
    
    Ok(value)
}
```

### 3. æ‰¹é‡æ“ä½œ

```rust
fn batch_update(updates: Vec<(String, String)>) -> Result<()> {
    let conn = Connection::open(&db_path)?;
    let tx = conn.transaction()?;
    
    // å‡†å¤‡è¯­å¥
    let mut stmt = tx.prepare(
        "INSERT OR REPLACE INTO ItemTable (key, value) VALUES (?1, ?2)"
    )?;
    
    // æ‰¹é‡æ‰§è¡Œ
    for (key, value) in updates {
        stmt.execute(params![key, value])?;
    }
    
    drop(stmt);
    tx.commit()?;
    
    Ok(())
}
```

## ğŸ“ æœ€ä½³å®è·µ

### 1. é”™è¯¯å¤„ç†

```rust
// ä½¿ç”¨ Result å’Œ ?
fn operation() -> Result<Data> {
    let step1 = step_one()?;
    let step2 = step_two(step1)?;
    let step3 = step_three(step2)?;
    Ok(step3)
}

// æä¾›ä¸Šä¸‹æ–‡ä¿¡æ¯
use anyhow::Context;

fn with_context() -> Result<Data> {
    read_file()
        .context("è¯»å–é…ç½®æ–‡ä»¶å¤±è´¥")?;
    
    parse_data()
        .context("è§£ææ•°æ®å¤±è´¥")?;
}
```

### 2. èµ„æºç®¡ç†

```rust
// ä½¿ç”¨ RAII
fn process_file(path: &Path) -> Result<()> {
    let file = File::open(path)?;
    let reader = BufReader::new(file);
    
    for line in reader.lines() {
        process_line(line?)?;
    }
    
    Ok(())
    // file è‡ªåŠ¨å…³é—­
}
```

### 3. æ—¥å¿—è®°å½•

```rust
fn important_operation() -> Result<()> {
    log_info!("å¼€å§‹æ‰§è¡Œé‡è¦æ“ä½œ");
    
    let result = do_work()
        .map_err(|e| {
            log_error!("æ“ä½œå¤±è´¥: {}", e);
            e
        })?;
    
    log_info!("æ“ä½œæˆåŠŸå®Œæˆ");
    Ok(result)
}
```

## âš ï¸ æ³¨æ„äº‹é¡¹

1. **çº¿ç¨‹å®‰å…¨**ï¼šä½¿ç”¨ Arc<Mutex<T>> å…±äº«çŠ¶æ€
2. **é”™è¯¯ä¼ æ’­**ï¼šä½¿ç”¨ ? æ“ä½œç¬¦ç®€åŒ–é”™è¯¯å¤„ç†
3. **èµ„æºæ¸…ç†**ï¼šç¡®ä¿æ–‡ä»¶ã€è¿æ¥ç­‰èµ„æºæ­£ç¡®é‡Šæ”¾
4. **è·¨å¹³å°**ï¼šä½¿ç”¨æ¡ä»¶ç¼–è¯‘å¤„ç†å¹³å°å·®å¼‚
5. **æ€§èƒ½è€ƒè™‘**ï¼šé¿å…é˜»å¡ä¸»çº¿ç¨‹ï¼Œä½¿ç”¨å¼‚æ­¥æ“ä½œ

---

**æœ€åæ›´æ–°**ï¼š2025-10-28
**æ–‡æ¡£ç‰ˆæœ¬**ï¼š1.0.0

