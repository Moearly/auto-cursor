# 08 - 后端架构

## 📋 架构概述

Auto-Cursor 后端采用 Rust + Tauri 2.0 构建，提供高性能的系统级操作和数据库管理能力。

## 🏗️ 模块结构

```
src-tauri/src/
├── main.rs              # 应用入口
├── lib.rs               # Tauri命令注册中心（37869行）
├── machine_id.rs        # 机器ID管理模块（1694行）
├── account_manager.rs   # 账号管理模块（1428行）
├── auth_checker.rs      # 认证检查模块（2061行）
└── logger.rs            # 日志系统模块
```

## 📦 核心模块

### 1. lib.rs - 命令注册中心

这是整个后端的核心，负责注册所有 Tauri 命令并初始化应用。

```rust
#[cfg_attr(mobile, tauri::mobile_entry_point)]
pub fn run() {
    tauri::Builder::default()
        // 插件注册
        .plugin(tauri_plugin_opener::init())
        .plugin(tauri_plugin_fs::init())
        .plugin(tauri_plugin_dialog::init())
        
        // 命令注册
        .invoke_handler(tauri::generate_handler![
            // ========== 机器ID管理 ==========
            check_cursor_installation,
            get_cursor_paths,
            find_backups,
            extract_ids_from_backup,
            create_backup,
            reset_machine_ids,
            complete_cursor_reset,
            get_current_machine_ids,
            get_machine_id_file_content,
            get_backup_directory_info,
            
            // ========== 账号管理 ==========
            list_accounts,
            switch_account,
            switch_account_with_token,
            add_account,
            delete_account,
            logout_account,
            get_current_account,
            
            // ========== 认证检查 ==========
            check_cursor_auth,
            get_usage_stats,
            get_aggregated_usage,
            get_user_analytics,
            
            // ========== 自动注册 ==========
            register_cursor_account,
            register_cursor_account_with_config,
            register_cursor_account_batch,
            input_verification_code_for_registration,
            
            // ========== 虚拟卡生成 ==========
            generate_virtual_card,
            save_bank_card_config,
            load_bank_card_config,
            list_bank_card_configs,
            delete_bank_card_config,
            
            // ========== 邮箱配置 ==========
            save_email_config,
            load_email_config,
            
            // ========== 系统工具 ==========
            debug_windows_cursor_paths,
            set_custom_cursor_path,
            get_custom_cursor_path,
            clear_custom_cursor_path,
            test_logging,
            
            // ========== 更新检查 ==========
            check_for_updates,
        ])
        
        .run(tauri::generate_context!())
        .expect("error while running tauri application");
}
```

### 2. machine_id.rs - 机器ID管理

负责 Cursor 机器标识的生成、备份、恢复和系统级更新。

#### 核心结构

```rust
pub struct MachineIdRestorer {
    pub db_path: PathBuf,           // storage.json 路径
    pub sqlite_path: PathBuf,       // state.vscdb 路径
    pub log_file_path: PathBuf,     // 日志文件路径
}

impl MachineIdRestorer {
    // 创建实例
    pub fn new() -> Result<Self> {
        let (db_path, sqlite_path) = Self::get_cursor_paths()?;
        let timestamp = chrono::Local::now().format("%Y%m%d_%H%M%S").to_string();
        let log_file_path = std::env::current_dir()?
            .join(format!("cursor_reset_{}.log", timestamp));
        
        Ok(Self {
            db_path,
            sqlite_path,
            log_file_path,
        })
    }
    
    // 生成新机器ID
    pub fn generate_new_machine_ids(&self) -> Result<MachineIds> {
        // UUID v4
        let dev_device_id = Uuid::new_v4().to_string();
        
        // SHA256 (64字符)
        let mut machine_id_data = [0u8; 32];
        rand::thread_rng().fill(&mut machine_id_data);
        let machine_id = format!("{:x}", Sha256::digest(&machine_id_data));
        
        // SHA512 (128字符)
        let mut mac_machine_id_data = [0u8; 64];
        rand::thread_rng().fill(&mut mac_machine_id_data);
        let mac_machine_id = format!("{:x}", Sha512::digest(&mac_machine_id_data));
        
        // GUID格式
        let sqm_id = format!("{{{}}}", Uuid::new_v4().to_string().to_uppercase());
        
        Ok(MachineIds {
            dev_device_id: dev_device_id.clone(),
            mac_machine_id,
            machine_id,
            sqm_id,
            service_machine_id: dev_device_id,
        })
    }
    
    // 完整重置流程
    pub fn complete_cursor_reset(&self) -> Result<ResetResult> {
        // 1. 记录系统信息
        self.log_system_info();
        
        // 2. 创建备份
        self.create_backup()?;
        
        // 3. 生成新ID
        let new_ids = self.generate_new_machine_ids()?;
        
        // 4. 更新所有配置
        self.update_storage_file(&new_ids)?;
        self.update_sqlite_db(&new_ids)?;
        self.update_machine_id_file(&new_ids.dev_device_id)?;
        self.update_system_ids(&new_ids)?;
        
        // 5. 修改JS文件
        self.modify_main_js(&main_js_path)?;
        self.modify_workbench_js(&workbench_path)?;
        
        Ok(ResetResult {
            success: true,
            message: "重置成功".to_string(),
            details: vec![],
            new_ids: Some(new_ids),
        })
    }
}
```

#### 平台特定实现

```rust
// Windows 路径
#[cfg(target_os = "windows")]
fn get_cursor_paths() -> Result<(PathBuf, PathBuf)> {
    let appdata = std::env::var("APPDATA")?;
    let db_path = PathBuf::from(&appdata)
        .join("Cursor")
        .join("User")
        .join("globalStorage")
        .join("storage.json");
    let sqlite_path = PathBuf::from(&appdata)
        .join("Cursor")
        .join("User")
        .join("globalStorage")
        .join("state.vscdb");
    Ok((db_path, sqlite_path))
}

// macOS 路径
#[cfg(target_os = "macos")]
fn get_cursor_paths() -> Result<(PathBuf, PathBuf)> {
    let home = dirs::home_dir()?;
    let db_path = home
        .join("Library")
        .join("Application Support")
        .join("Cursor")
        .join("User")
        .join("globalStorage")
        .join("storage.json");
    let sqlite_path = home
        .join("Library")
        .join("Application Support")
        .join("Cursor")
        .join("User")
        .join("globalStorage")
        .join("state.vscdb");
    Ok((db_path, sqlite_path))
}

// Linux 路径
#[cfg(target_os = "linux")]
fn get_cursor_paths() -> Result<(PathBuf, PathBuf)> {
    let home = dirs::home_dir()?;
    let db_path = home
        .join(".config")
        .join("Cursor")
        .join("User")
        .join("globalStorage")
        .join("storage.json");
    let sqlite_path = home
        .join(".config")
        .join("Cursor")
        .join("User")
        .join("globalStorage")
        .join("state.vscdb");
    Ok((db_path, sqlite_path))
}
```

### 3. account_manager.rs - 账号管理

负责 Cursor 账号的切换、添加、删除和登录状态管理。

#### 核心功能

```rust
pub struct AccountManager;

impl AccountManager {
    // 快速切换账号（邮箱+Token）
    pub fn switch_account_with_token(
        email: String,
        token: String,
        auth_type: Option<String>,
    ) -> Result<SwitchAccountResult> {
        let mut details = Vec::new();
        
        // 1. 检测并强制关闭 Cursor
        if Self::is_cursor_running() {
            log_info!("检测到 Cursor 正在运行，准备关闭...");
            Self::force_close_cursor()?;
            details.push("强制关闭 Cursor 进程".to_string());
            std::thread::sleep(std::time::Duration::from_secs(2));
        }
        
        // 2. 处理 Token 格式
        let processed_token = if token.contains("%3A%3A") {
            token.split("%3A%3A").nth(1).unwrap_or(&token)
        } else if token.contains("::") {
            token.split("::").nth(1).unwrap_or(&token)
        } else {
            &token
        };
        
        // 3. 更新数据库
        let (_, sqlite_path) = Self::get_cursor_paths()?;
        let conn = Connection::open(&sqlite_path)?;
        let tx = conn.transaction()?;
        
        let auth_type_value = auth_type.unwrap_or_else(|| "Auth_0".to_string());
        
        // 更新所有必要字段
        let fields = vec![
            ("cursorAuth/cachedEmail", &email),
            ("cursor.email", &email),
            ("cursorAuth/accessToken", processed_token),
            ("cursorAuth/refreshToken", processed_token),
            ("cursor.accessToken", processed_token),
            ("cursorAuth/cachedSignUpType", &auth_type_value),
        ];
        
        for (key, value) in fields {
            tx.execute(
                "INSERT OR REPLACE INTO ItemTable (key, value) VALUES (?1, ?2)",
                params![key, value],
            )?;
        }
        
        tx.commit()?;
        
        // 4. 等待数据库写入完成
        std::thread::sleep(std::time::Duration::from_millis(500));
        
        Ok(SwitchAccountResult {
            success: true,
            message: "账号切换成功".to_string(),
            details,
        })
    }
    
    // 检测 Cursor 是否运行
    fn is_cursor_running() -> bool {
        #[cfg(target_os = "windows")]
        {
            let output = Command::new("tasklist")
                .args(&["/FI", "IMAGENAME eq Cursor.exe"])
                .output();
            if let Ok(output) = output {
                return String::from_utf8_lossy(&output.stdout).contains("Cursor.exe");
            }
        }
        
        #[cfg(any(target_os = "macos", target_os = "linux"))]
        {
            let output = Command::new("pgrep")
                .arg("-f")
                .arg("Cursor")
                .output();
            if let Ok(output) = output {
                return output.status.success();
            }
        }
        
        false
    }
    
    // 强制关闭 Cursor
    fn force_close_cursor() -> Result<()> {
        #[cfg(target_os = "windows")]
        {
            Command::new("taskkill")
                .args(&["/F", "/IM", "Cursor.exe"])
                .output()?;
        }
        
        #[cfg(target_os = "macos")]
        {
            Command::new("pkill")
                .arg("-f")
                .arg("Cursor")
                .output()?;
        }
        
        #[cfg(target_os = "linux")]
        {
            Command::new("pkill")
                .arg("-f")
                .arg("cursor")
                .output()?;
        }
        
        Ok(())
    }
}
```

### 4. auth_checker.rs - 认证检查

负责查询 Cursor 的登录状态和使用统计。

#### 核心功能

```rust
pub struct AuthChecker;

impl AuthChecker {
    // 检查认证状态
    pub async fn check_auth() -> Result<UserAuthInfo> {
        // 1. 从数据库获取 Token
        let token = Self::get_token_from_db()?;
        
        // 2. 调用 API 验证
        let client = reqwest::Client::new();
        let response = client
            .get("https://api.cursor.sh/api/auth/status")
            .header("Authorization", format!("Bearer {}", token))
            .send()
            .await?;
        
        if response.status().is_success() {
            let auth_data: serde_json::Value = response.json().await?;
            
            Ok(UserAuthInfo {
                is_authorized: true,
                token_valid: true,
                account_info: Some(Self::parse_account_info(&auth_data)),
                // ...
            })
        } else {
            Ok(UserAuthInfo {
                is_authorized: false,
                token_valid: false,
                // ...
            })
        }
    }
    
    // 获取使用统计
    pub async fn get_usage_stats(
        start_date: Option<u64>,
        end_date: Option<u64>,
    ) -> Result<AggregatedUsageData> {
        let token = Self::get_token_from_db()?;
        
        let client = reqwest::Client::new();
        let response = client
            .post("https://api.cursor.sh/api/usage")
            .header("Authorization", format!("Bearer {}", token))
            .json(&serde_json::json!({
                "start_date": start_date.unwrap_or(Self::default_start_date()),
                "end_date": end_date.unwrap_or(Self::default_end_date()),
                "team_id": 0
            }))
            .send()
            .await?;
        
        let usage_data: AggregatedUsageData = response.json().await?;
        Ok(usage_data)
    }
    
    // 从数据库获取 Token
    fn get_token_from_db() -> Result<String> {
        let (_, sqlite_path) = get_cursor_paths()?;
        let conn = Connection::open(&sqlite_path)?;
        
        let token: String = conn.query_row(
            "SELECT value FROM ItemTable WHERE key = 'cursorAuth/accessToken'",
            [],
            |row| row.get(0),
        )?;
        
        Ok(token)
    }
}
```

### 5. logger.rs - 日志系统

提供统一的日志记录功能。

```rust
// 日志宏定义
#[macro_export]
macro_rules! log_info {
    ($($arg:tt)*) => {
        println!("[INFO] {}", format!($($arg)*));
    };
}

#[macro_export]
macro_rules! log_warn {
    ($($arg:tt)*) => {
        println!("[WARN] {}", format!($($arg)*));
    };
}

#[macro_export]
macro_rules! log_error {
    ($($arg:tt)*) => {
        eprintln!("[ERROR] {}", format!($($arg)*));
    };
}

#[macro_export]
macro_rules! log_debug {
    ($($arg:tt)*) => {
        #[cfg(debug_assertions)]
        println!("[DEBUG] {}", format!($($arg)*));
    };
}
```

## 🔧 Tauri 命令模式

### 命令定义

```rust
#[tauri::command]
async fn example_command(
    param1: String,
    param2: Option<i32>,
    app_handle: tauri::AppHandle,
) -> Result<ResponseType, String> {
    log_info!("执行命令: example_command");
    
    // 业务逻辑
    let result = do_something(param1, param2)?;
    
    // 发送事件到前端
    app_handle.emit("event-name", &result).ok();
    
    Ok(result)
}
```

### 错误处理

```rust
// 使用 Result 类型
#[tauri::command]
fn may_fail() -> Result<String, String> {
    some_operation()
        .map_err(|e| format!("操作失败: {}", e))
}

// 使用 anyhow
use anyhow::{Result, Context};

fn complex_operation() -> Result<Data> {
    let data = read_file()
        .context("读取文件失败")?;
    
    let processed = process_data(data)
        .context("处理数据失败")?;
    
    Ok(processed)
}
```

## 📊 数据库操作

### SQLite 事务

```rust
use rusqlite::{Connection, params, Transaction};

fn update_multiple_fields(conn: &Connection) -> Result<()> {
    // 开启事务
    let tx = conn.transaction()?;
    
    // 执行多个操作
    tx.execute(
        "INSERT OR REPLACE INTO ItemTable (key, value) VALUES (?1, ?2)",
        params!["key1", "value1"],
    )?;
    
    tx.execute(
        "INSERT OR REPLACE INTO ItemTable (key, value) VALUES (?1, ?2)",
        params!["key2", "value2"],
    )?;
    
    // 提交事务
    tx.commit()?;
    
    Ok(())
}
```

### 查询操作

```rust
// 查询单行
let value: String = conn.query_row(
    "SELECT value FROM ItemTable WHERE key = ?1",
    params!["some_key"],
    |row| row.get(0),
)?;

// 查询多行
let mut stmt = conn.prepare("SELECT key, value FROM ItemTable")?;
let rows = stmt.query_map([], |row| {
    Ok((
        row.get::<_, String>(0)?,
        row.get::<_, String>(1)?,
    ))
})?;

for row in rows {
    let (key, value) = row?;
    println!("{}: {}", key, value);
}
```

## 🔐 安全性

### 1. 进程隔离

```rust
// Windows: 创建隐藏窗口
#[cfg(target_os = "windows")]
fn create_hidden_command(program: &str) -> Command {
    use std::os::windows::process::CommandExt;
    const CREATE_NO_WINDOW: u32 = 0x08000000;
    
    let mut cmd = Command::new(program);
    cmd.creation_flags(CREATE_NO_WINDOW);
    cmd
}
```

### 2. 权限检查

```rust
fn require_admin_permission() -> Result<()> {
    #[cfg(target_os = "windows")]
    {
        // 检查是否有管理员权限
        if !is_elevated() {
            return Err(anyhow!("需要管理员权限"));
        }
    }
    
    Ok(())
}
```

### 3. 数据验证

```rust
fn validate_email(email: &str) -> Result<()> {
    let email_regex = Regex::new(r"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$")?;
    
    if !email_regex.is_match(email) {
        return Err(anyhow!("无效的邮箱地址"));
    }
    
    Ok(())
}

fn validate_token(token: &str) -> Result<()> {
    if token.len() < 100 {
        return Err(anyhow!("Token长度不足"));
    }
    
    // JWT 格式验证
    if !token.starts_with("eyJ") {
        return Err(anyhow!("无效的Token格式"));
    }
    
    Ok(())
}
```

## 🚀 性能优化

### 1. 异步操作

```rust
use tokio::task;

#[tauri::command]
async fn async_operation() -> Result<String, String> {
    // 并发执行多个任务
    let (result1, result2) = tokio::join!(
        task::spawn(async { fetch_data_1().await }),
        task::spawn(async { fetch_data_2().await }),
    );
    
    let data1 = result1.map_err(|e| e.to_string())??;
    let data2 = result2.map_err(|e| e.to_string())??;
    
    Ok(format!("{} + {}", data1, data2))
}
```

### 2. 缓存机制

```rust
use std::sync::{Arc, Mutex};
use std::collections::HashMap;

lazy_static! {
    static ref CACHE: Arc<Mutex<HashMap<String, String>>> = 
        Arc::new(Mutex::new(HashMap::new()));
}

fn get_cached_or_fetch(key: &str) -> Result<String> {
    // 检查缓存
    {
        let cache = CACHE.lock().unwrap();
        if let Some(value) = cache.get(key) {
            return Ok(value.clone());
        }
    }
    
    // 获取数据
    let value = fetch_data(key)?;
    
    // 更新缓存
    {
        let mut cache = CACHE.lock().unwrap();
        cache.insert(key.to_string(), value.clone());
    }
    
    Ok(value)
}
```

### 3. 批量操作

```rust
fn batch_update(updates: Vec<(String, String)>) -> Result<()> {
    let conn = Connection::open(&db_path)?;
    let tx = conn.transaction()?;
    
    // 准备语句
    let mut stmt = tx.prepare(
        "INSERT OR REPLACE INTO ItemTable (key, value) VALUES (?1, ?2)"
    )?;
    
    // 批量执行
    for (key, value) in updates {
        stmt.execute(params![key, value])?;
    }
    
    drop(stmt);
    tx.commit()?;
    
    Ok(())
}
```

## 📝 最佳实践

### 1. 错误处理

```rust
// 使用 Result 和 ?
fn operation() -> Result<Data> {
    let step1 = step_one()?;
    let step2 = step_two(step1)?;
    let step3 = step_three(step2)?;
    Ok(step3)
}

// 提供上下文信息
use anyhow::Context;

fn with_context() -> Result<Data> {
    read_file()
        .context("读取配置文件失败")?;
    
    parse_data()
        .context("解析数据失败")?;
}
```

### 2. 资源管理

```rust
// 使用 RAII
fn process_file(path: &Path) -> Result<()> {
    let file = File::open(path)?;
    let reader = BufReader::new(file);
    
    for line in reader.lines() {
        process_line(line?)?;
    }
    
    Ok(())
    // file 自动关闭
}
```

### 3. 日志记录

```rust
fn important_operation() -> Result<()> {
    log_info!("开始执行重要操作");
    
    let result = do_work()
        .map_err(|e| {
            log_error!("操作失败: {}", e);
            e
        })?;
    
    log_info!("操作成功完成");
    Ok(result)
}
```

## ⚠️ 注意事项

1. **线程安全**：使用 Arc<Mutex<T>> 共享状态
2. **错误传播**：使用 ? 操作符简化错误处理
3. **资源清理**：确保文件、连接等资源正确释放
4. **跨平台**：使用条件编译处理平台差异
5. **性能考虑**：避免阻塞主线程，使用异步操作

---

**最后更新**：2025-10-28
**文档版本**：1.0.0

