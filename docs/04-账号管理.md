# 04 - 账号管理

## 📋 功能概述

账号管理模块提供了完整的 Cursor 账号管理功能，包括账号列表管理、快速切换、Token注入和登录状态管理。

## 🎯 核心功能

### 1. 账号列表管理
- ✅ 添加新账号
- ✅ 删除账号
- ✅ 查看所有账号
- ✅ 标记当前账号
- ✅ 账号信息持久化

### 2. 账号切换
- ✅ 从列表选择切换
- ✅ 快速切换（邮箱+Token）
- ✅ 强制关闭 Cursor 进程
- ✅ 数据库认证信息更新
- ✅ 自动重启提示

### 3. 认证管理
- ✅ 支持多种认证类型（Auth_0/Google/GitHub）
- ✅ Token 格式处理
- ✅ RefreshToken 管理
- ✅ 登录状态检查

### 4. 退出登录
- ✅ 清除认证信息
- ✅ 清空 Token
- ✅ 重置登录状态

## 🗂️ 数据结构

### AccountInfo 结构

```rust
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AccountInfo {
    pub email: String,                          // 邮箱地址
    pub token: String,                          // 访问令牌
    pub refresh_token: Option<String>,          // 刷新令牌
    pub workos_cursor_session_token: Option<String>,  // 会话令牌
    pub is_current: bool,                       // 是否为当前账号
    pub created_at: String,                     // 创建时间
}
```

### 账号存储文件

```json
// Cursor/User/globalStorage/account.json
[
  {
    "email": "user@example.com",
    "token": "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9...",
    "refresh_token": "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9...",
    "workos_cursor_session_token": null,
    "is_current": true,
    "created_at": "2025-10-28T10:30:00Z"
  }
]
```

## 🔑 关键数据库字段

### SQLite 数据库字段（state.vscdb）

```rust
// 必须更新的字段（按重要性排序）
let auth_fields = vec![
    // 1. 邮箱字段（最重要！）
    ("cursorAuth/cachedEmail", email),           // Cursor识别登录状态的关键
    ("cursor.email", email),                     // 额外邮箱字段
    
    // 2. Token字段
    ("cursorAuth/accessToken", processed_token), // 访问令牌
    ("cursorAuth/refreshToken", processed_token),// 刷新令牌（与accessToken相同）
    ("cursor.accessToken", processed_token),     // 额外token字段
    
    // 3. 认证类型
    ("cursorAuth/cachedSignUpType", auth_type),  // Auth_0/Google/GitHub
];
```

### 字段说明

| 字段名 | 类型 | 说明 | 重要性 |
|--------|------|------|--------|
| `cursorAuth/cachedEmail` | String | 主要邮箱字段 | ⭐⭐⭐⭐⭐ |
| `cursorAuth/accessToken` | String | 访问令牌 | ⭐⭐⭐⭐ |
| `cursorAuth/refreshToken` | String | 刷新令牌 | ⭐⭐⭐⭐ |
| `cursorAuth/cachedSignUpType` | String | 认证类型 | ⭐⭐⭐ |
| `cursor.email` | String | 额外邮箱字段 | ⭐⭐ |
| `cursor.accessToken` | String | 额外token字段 | ⭐⭐ |

## 🔧 核心实现

### 1. Token 处理逻辑

```rust
/// 处理包含分隔符的token
fn process_token(token: &str) -> &str {
    // 处理格式: user_01XXX%3A%3AeyJhbGci... → eyJhbGci...
    if token.contains("%3A%3A") {
        token.split("%3A%3A").nth(1).unwrap_or(token)
    }
    // 处理格式: user_01XXX::eyJhbGci... → eyJhbGci...
    else if token.contains("::") {
        token.split("::").nth(1).unwrap_or(token)
    }
    // 已经是纯JWT格式
    else {
        token
    }
}
```

**Token格式示例**：
```
完整格式: user_01XXXXXXX%3A%3AeyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9...
处理后:   eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9...
```

### 2. 账号切换（快速切换）

```rust
pub fn switch_account_with_token(
    email: String,
    token: String,
    auth_type: Option<String>,
) -> Result<SwitchAccountResult> {
    let mut details = Vec::new();
    
    // 步骤1: 检测并关闭 Cursor 进程（关键！）
    if Self::is_cursor_running() {
        log_info!("🔍 检测到 Cursor 正在运行，准备关闭...");
        Self::force_close_cursor()?;
        details.push("强制关闭 Cursor 进程".to_string());
        
        // 等待进程完全关闭
        std::thread::sleep(std::time::Duration::from_secs(2));
    }
    
    // 步骤2: 处理 Token
    let processed_token = if token.contains("%3A%3A") {
        token.split("%3A%3A").nth(1).unwrap_or(&token)
    } else if token.contains("::") {
        token.split("::").nth(1).unwrap_or(&token)
    } else {
        &token
    };
    
    // 步骤3: 更新数据库
    let (_, sqlite_path) = Self::get_cursor_paths()?;
    let conn = Connection::open(&sqlite_path)?;
    
    // 开启事务
    let tx = conn.transaction()?;
    
    // 认证类型
    let auth_type_value = auth_type.unwrap_or_else(|| "Auth_0".to_string());
    
    // 更新所有必要字段
    let auth_fields = vec![
        ("cursorAuth/cachedEmail", &email),
        ("cursor.email", &email),
        ("cursorAuth/accessToken", processed_token),
        ("cursorAuth/refreshToken", processed_token),
        ("cursor.accessToken", processed_token),
        ("cursorAuth/cachedSignUpType", &auth_type_value),
    ];
    
    for (key, value) in auth_fields {
        tx.execute(
            "INSERT OR REPLACE INTO ItemTable (key, value) VALUES (?1, ?2)",
            params![key, value],
        )?;
        details.push(format!("更新字段: {}", key));
    }
    
    // 提交事务
    tx.commit()?;
    
    // 步骤4: 等待数据库写入完成
    std::thread::sleep(std::time::Duration::from_millis(500));
    
    details.push("数据库更新完成".to_string());
    details.push("请手动重启 Cursor 以应用更改".to_string());
    
    Ok(SwitchAccountResult {
        success: true,
        message: "账号切换成功".to_string(),
        details,
    })
}
```

### 3. 强制关闭 Cursor 进程

```rust
/// 检测 Cursor 是否在运行
fn is_cursor_running() -> bool {
    #[cfg(target_os = "windows")]
    {
        let output = Command::new("tasklist")
            .args(&["/FI", "IMAGENAME eq Cursor.exe"])
            .output();
        
        if let Ok(output) = output {
            let stdout = String::from_utf8_lossy(&output.stdout);
            return stdout.contains("Cursor.exe");
        }
    }
    
    #[cfg(target_os = "macos")]
    {
        let output = Command::new("pgrep")
            .arg("-f")
            .arg("Cursor")
            .output();
        
        if let Ok(output) = output {
            return output.status.success();
        }
    }
    
    #[cfg(target_os = "linux")]
    {
        let output = Command::new("pgrep")
            .arg("-f")
            .arg("cursor")
            .output();
        
        if let Ok(output) = output {
            return output.status.success();
        }
    }
    
    false
}

/// 强制关闭 Cursor 进程
fn force_close_cursor() -> Result<()> {
    #[cfg(target_os = "windows")]
    {
        Command::new("taskkill")
            .args(&["/F", "/IM", "Cursor.exe"])
            .output()?;
    }
    
    #[cfg(target_os = "macos")]
    {
        Command::new("pkill")
            .arg("-f")
            .arg("Cursor")
            .output()?;
    }
    
    #[cfg(target_os = "linux")]
    {
        Command::new("pkill")
            .arg("-f")
            .arg("cursor")
            .output()?;
    }
    
    Ok(())
}
```

### 4. 添加账号

```rust
pub fn add_account(
    email: String,
    token: String,
    refresh_token: Option<String>,
) -> Result<AccountInfo> {
    let account_file = Self::get_account_file_path()?;
    
    // 读取现有账号
    let mut accounts = if account_file.exists() {
        let content = fs::read_to_string(&account_file)?;
        serde_json::from_str(&content).unwrap_or_else(|_| Vec::new())
    } else {
        Vec::new()
    };
    
    // 检查是否已存在
    if accounts.iter().any(|a: &AccountInfo| a.email == email) {
        return Err(anyhow!("账号已存在"));
    }
    
    // 创建新账号
    let new_account = AccountInfo {
        email: email.clone(),
        token: token.clone(),
        refresh_token,
        workos_cursor_session_token: None,
        is_current: false,
        created_at: chrono::Local::now().to_rfc3339(),
    };
    
    // 添加到列表
    accounts.push(new_account.clone());
    
    // 保存到文件
    let json = serde_json::to_string_pretty(&accounts)?;
    fs::write(&account_file, json)?;
    
    Ok(new_account)
}
```

### 5. 退出登录

```rust
pub fn logout_account() -> Result<LogoutResult> {
    let mut details = Vec::new();
    
    // 步骤1: 强制关闭 Cursor
    if Self::is_cursor_running() {
        Self::force_close_cursor()?;
        details.push("关闭 Cursor 进程".to_string());
        std::thread::sleep(std::time::Duration::from_secs(2));
    }
    
    // 步骤2: 清除数据库中的认证信息
    let (_, sqlite_path) = Self::get_cursor_paths()?;
    let conn = Connection::open(&sqlite_path)?;
    
    let tx = conn.transaction()?;
    
    // 删除所有认证相关字段
    let auth_keys = vec![
        "cursorAuth/cachedEmail",
        "cursorAuth/accessToken",
        "cursorAuth/refreshToken",
        "cursorAuth/cachedSignUpType",
        "cursor.email",
        "cursor.accessToken",
    ];
    
    for key in auth_keys {
        tx.execute("DELETE FROM ItemTable WHERE key = ?1", params![key])?;
        details.push(format!("清除字段: {}", key));
    }
    
    tx.commit()?;
    
    // 步骤3: 更新账号列表
    let account_file = Self::get_account_file_path()?;
    if account_file.exists() {
        let content = fs::read_to_string(&account_file)?;
        let mut accounts: Vec<AccountInfo> = serde_json::from_str(&content)?;
        
        // 取消所有账号的当前标记
        for account in &mut accounts {
            account.is_current = false;
        }
        
        let json = serde_json::to_string_pretty(&accounts)?;
        fs::write(&account_file, json)?;
    }
    
    details.push("退出登录成功".to_string());
    details.push("请重启 Cursor".to_string());
    
    Ok(LogoutResult {
        success: true,
        message: "退出登录成功".to_string(),
        details,
    })
}
```

## 🎨 前端界面

### TokenManagePage 组件

```typescript
export const TokenManagePage: React.FC = () => {
  const [accounts, setAccounts] = useState<AccountInfo[]>([]);
  const [showQuickSwitch, setShowQuickSwitch] = useState(false);
  const [quickSwitchForm, setQuickSwitchForm] = useState({
    email: '',
    token: '',
    authType: 'Auth_0'
  });
  
  // 加载账号列表
  const loadAccounts = async () => {
    const result = await AccountService.listAccounts();
    setAccounts(result.accounts);
  };
  
  // 快速切换
  const handleQuickSwitch = async () => {
    const result = await AccountService.switchAccountWithToken(
      quickSwitchForm.email,
      quickSwitchForm.token,
      quickSwitchForm.authType
    );
    
    if (result.success) {
      showToast('账号切换成功，请重启 Cursor', 'success');
    }
  };
  
  // 从列表切换
  const handleSwitchAccount = async (account: AccountInfo) => {
    const result = await AccountService.switchAccount(account.email);
    if (result.success) {
      showToast('账号切换成功', 'success');
      loadAccounts();
    }
  };
  
  // 删除账号
  const handleDeleteAccount = async (email: string) => {
    await AccountService.deleteAccount(email);
    loadAccounts();
  };
  
  return (
    <div className="space-y-6">
      {/* 快速切换表单 */}
      <div className="bg-white rounded-lg shadow p-6">
        <h2 className="text-xl font-bold mb-4">🚀 快速切换</h2>
        <input
          type="email"
          placeholder="邮箱地址"
          value={quickSwitchForm.email}
          onChange={(e) => setQuickSwitchForm({
            ...quickSwitchForm,
            email: e.target.value
          })}
        />
        <input
          type="text"
          placeholder="Token"
          value={quickSwitchForm.token}
          onChange={(e) => setQuickSwitchForm({
            ...quickSwitchForm,
            token: e.target.value
          })}
        />
        <select
          value={quickSwitchForm.authType}
          onChange={(e) => setQuickSwitchForm({
            ...quickSwitchForm,
            authType: e.target.value
          })}
        >
          <option value="Auth_0">Auth_0</option>
          <option value="Google">Google</option>
          <option value="GitHub">GitHub</option>
        </select>
        <button onClick={handleQuickSwitch}>
          🚀 立即切换
        </button>
      </div>
      
      {/* 账号列表 */}
      <div className="bg-white rounded-lg shadow p-6">
        <h2 className="text-xl font-bold mb-4">📋 账号列表</h2>
        {accounts.map((account) => (
          <div key={account.email} className="border-b py-4">
            <div className="flex justify-between items-center">
              <div>
                <p className="font-medium">{account.email}</p>
                <p className="text-sm text-gray-500">
                  {account.is_current ? '✅ 当前账号' : ''}
                </p>
              </div>
              <div className="space-x-2">
                <button onClick={() => handleSwitchAccount(account)}>
                  切换
                </button>
                <button onClick={() => handleDeleteAccount(account.email)}>
                  删除
                </button>
              </div>
            </div>
          </div>
        ))}
      </div>
    </div>
  );
};
```

## 🔍 故障排除

### 常见问题

#### 1. 切换后仍显示未登录

**原因分析**：
- Token格式不正确
- 数据库字段未全部更新
- Cursor进程未完全关闭

**解决方案**：
```bash
# 1. 检查Token格式
# 正确: eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9...
# 错误: user_01XXX%3A%3AeyJhbGci...（需要处理）

# 2. 手动关闭Cursor
# Windows
taskkill /F /IM Cursor.exe

# macOS/Linux
pkill -f Cursor

# 3. 检查数据库
sqlite3 state.vscdb "SELECT key, value FROM ItemTable WHERE key LIKE '%cursor%'"
```

#### 2. ERROR_NOT_LOGGED_IN 错误

**原因**：
- `cursorAuth/cachedEmail` 字段未更新
- Cursor缓存了旧的认证状态

**解决方案**：
1. 确保强制关闭了Cursor进程
2. 检查所有必要字段是否已更新
3. 等待500ms后再重启Cursor
4. 清除Cursor缓存（可选）

#### 3. RefreshToken 问题

**重要发现**：
- RefreshToken 实际上就是 AccessToken
- 两者存储相同的JWT值
- 不需要单独获取RefreshToken

```rust
// 正确做法
let token = "eyJhbGci...";
update_field("cursorAuth/accessToken", token);
update_field("cursorAuth/refreshToken", token);  // 相同值
```

## ⚙️ 配置选项

### 认证类型

| 类型 | 说明 | 使用场景 |
|------|------|----------|
| Auth_0 | 默认认证 | 邮箱密码注册 |
| Google | Google账号 | Google登录 |
| GitHub | GitHub账号 | GitHub登录 |

### Token格式

```
完整格式: user_01XXXXXXX%3A%3AeyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9...
简化格式: user_01XXXXXXX::eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9...
纯JWT:    eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9...
```

## 📊 使用流程图

```
用户操作
   ↓
输入邮箱和Token
   ↓
检测Cursor进程 ──→ 运行中? ──→ 强制关闭
   ↓                          ↓
处理Token格式              等待2秒
   ↓                          ↓
更新数据库字段 ←──────────────┘
   ↓
等待500ms
   ↓
提示重启Cursor
   ↓
用户手动重启
   ↓
加载新认证信息
   ↓
登录成功 ✅
```

## ⚠️ 重要提示

1. **必须关闭Cursor**：切换前必须强制关闭Cursor进程
2. **手动重启**：切换后需要手动重启Cursor
3. **Token格式**：确保Token格式正确（纯JWT）
4. **等待时间**：数据库更新后等待500ms
5. **备份数据**：操作前建议备份数据库

---

**最后更新**：2025-10-28
**文档版本**：1.0.0

