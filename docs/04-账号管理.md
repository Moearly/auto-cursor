# 04 - è´¦å·ç®¡ç†

## ğŸ“‹ åŠŸèƒ½æ¦‚è¿°

è´¦å·ç®¡ç†æ¨¡å—æä¾›äº†å®Œæ•´çš„ Cursor è´¦å·ç®¡ç†åŠŸèƒ½ï¼ŒåŒ…æ‹¬è´¦å·åˆ—è¡¨ç®¡ç†ã€å¿«é€Ÿåˆ‡æ¢ã€Tokenæ³¨å…¥å’Œç™»å½•çŠ¶æ€ç®¡ç†ã€‚

## ğŸ¯ æ ¸å¿ƒåŠŸèƒ½

### 1. è´¦å·åˆ—è¡¨ç®¡ç†
- âœ… æ·»åŠ æ–°è´¦å·
- âœ… åˆ é™¤è´¦å·
- âœ… æŸ¥çœ‹æ‰€æœ‰è´¦å·
- âœ… æ ‡è®°å½“å‰è´¦å·
- âœ… è´¦å·ä¿¡æ¯æŒä¹…åŒ–

### 2. è´¦å·åˆ‡æ¢
- âœ… ä»åˆ—è¡¨é€‰æ‹©åˆ‡æ¢
- âœ… å¿«é€Ÿåˆ‡æ¢ï¼ˆé‚®ç®±+Tokenï¼‰
- âœ… å¼ºåˆ¶å…³é—­ Cursor è¿›ç¨‹
- âœ… æ•°æ®åº“è®¤è¯ä¿¡æ¯æ›´æ–°
- âœ… è‡ªåŠ¨é‡å¯æç¤º

### 3. è®¤è¯ç®¡ç†
- âœ… æ”¯æŒå¤šç§è®¤è¯ç±»å‹ï¼ˆAuth_0/Google/GitHubï¼‰
- âœ… Token æ ¼å¼å¤„ç†
- âœ… RefreshToken ç®¡ç†
- âœ… ç™»å½•çŠ¶æ€æ£€æŸ¥

### 4. é€€å‡ºç™»å½•
- âœ… æ¸…é™¤è®¤è¯ä¿¡æ¯
- âœ… æ¸…ç©º Token
- âœ… é‡ç½®ç™»å½•çŠ¶æ€

## ğŸ—‚ï¸ æ•°æ®ç»“æ„

### AccountInfo ç»“æ„

```rust
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AccountInfo {
    pub email: String,                          // é‚®ç®±åœ°å€
    pub token: String,                          // è®¿é—®ä»¤ç‰Œ
    pub refresh_token: Option<String>,          // åˆ·æ–°ä»¤ç‰Œ
    pub workos_cursor_session_token: Option<String>,  // ä¼šè¯ä»¤ç‰Œ
    pub is_current: bool,                       // æ˜¯å¦ä¸ºå½“å‰è´¦å·
    pub created_at: String,                     // åˆ›å»ºæ—¶é—´
}
```

### è´¦å·å­˜å‚¨æ–‡ä»¶

```json
// Cursor/User/globalStorage/account.json
[
  {
    "email": "user@example.com",
    "token": "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9...",
    "refresh_token": "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9...",
    "workos_cursor_session_token": null,
    "is_current": true,
    "created_at": "2025-10-28T10:30:00Z"
  }
]
```

## ğŸ”‘ å…³é”®æ•°æ®åº“å­—æ®µ

### SQLite æ•°æ®åº“å­—æ®µï¼ˆstate.vscdbï¼‰

```rust
// å¿…é¡»æ›´æ–°çš„å­—æ®µï¼ˆæŒ‰é‡è¦æ€§æ’åºï¼‰
let auth_fields = vec![
    // 1. é‚®ç®±å­—æ®µï¼ˆæœ€é‡è¦ï¼ï¼‰
    ("cursorAuth/cachedEmail", email),           // Cursorè¯†åˆ«ç™»å½•çŠ¶æ€çš„å…³é”®
    ("cursor.email", email),                     // é¢å¤–é‚®ç®±å­—æ®µ
    
    // 2. Tokenå­—æ®µ
    ("cursorAuth/accessToken", processed_token), // è®¿é—®ä»¤ç‰Œ
    ("cursorAuth/refreshToken", processed_token),// åˆ·æ–°ä»¤ç‰Œï¼ˆä¸accessTokenç›¸åŒï¼‰
    ("cursor.accessToken", processed_token),     // é¢å¤–tokenå­—æ®µ
    
    // 3. è®¤è¯ç±»å‹
    ("cursorAuth/cachedSignUpType", auth_type),  // Auth_0/Google/GitHub
];
```

### å­—æ®µè¯´æ˜

| å­—æ®µå | ç±»å‹ | è¯´æ˜ | é‡è¦æ€§ |
|--------|------|------|--------|
| `cursorAuth/cachedEmail` | String | ä¸»è¦é‚®ç®±å­—æ®µ | â­â­â­â­â­ |
| `cursorAuth/accessToken` | String | è®¿é—®ä»¤ç‰Œ | â­â­â­â­ |
| `cursorAuth/refreshToken` | String | åˆ·æ–°ä»¤ç‰Œ | â­â­â­â­ |
| `cursorAuth/cachedSignUpType` | String | è®¤è¯ç±»å‹ | â­â­â­ |
| `cursor.email` | String | é¢å¤–é‚®ç®±å­—æ®µ | â­â­ |
| `cursor.accessToken` | String | é¢å¤–tokenå­—æ®µ | â­â­ |

## ğŸ”§ æ ¸å¿ƒå®ç°

### 1. Token å¤„ç†é€»è¾‘

```rust
/// å¤„ç†åŒ…å«åˆ†éš”ç¬¦çš„token
fn process_token(token: &str) -> &str {
    // å¤„ç†æ ¼å¼: user_01XXX%3A%3AeyJhbGci... â†’ eyJhbGci...
    if token.contains("%3A%3A") {
        token.split("%3A%3A").nth(1).unwrap_or(token)
    }
    // å¤„ç†æ ¼å¼: user_01XXX::eyJhbGci... â†’ eyJhbGci...
    else if token.contains("::") {
        token.split("::").nth(1).unwrap_or(token)
    }
    // å·²ç»æ˜¯çº¯JWTæ ¼å¼
    else {
        token
    }
}
```

**Tokenæ ¼å¼ç¤ºä¾‹**ï¼š
```
å®Œæ•´æ ¼å¼: user_01XXXXXXX%3A%3AeyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9...
å¤„ç†å:   eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9...
```

### 2. è´¦å·åˆ‡æ¢ï¼ˆå¿«é€Ÿåˆ‡æ¢ï¼‰

```rust
pub fn switch_account_with_token(
    email: String,
    token: String,
    auth_type: Option<String>,
) -> Result<SwitchAccountResult> {
    let mut details = Vec::new();
    
    // æ­¥éª¤1: æ£€æµ‹å¹¶å…³é—­ Cursor è¿›ç¨‹ï¼ˆå…³é”®ï¼ï¼‰
    if Self::is_cursor_running() {
        log_info!("ğŸ” æ£€æµ‹åˆ° Cursor æ­£åœ¨è¿è¡Œï¼Œå‡†å¤‡å…³é—­...");
        Self::force_close_cursor()?;
        details.push("å¼ºåˆ¶å…³é—­ Cursor è¿›ç¨‹".to_string());
        
        // ç­‰å¾…è¿›ç¨‹å®Œå…¨å…³é—­
        std::thread::sleep(std::time::Duration::from_secs(2));
    }
    
    // æ­¥éª¤2: å¤„ç† Token
    let processed_token = if token.contains("%3A%3A") {
        token.split("%3A%3A").nth(1).unwrap_or(&token)
    } else if token.contains("::") {
        token.split("::").nth(1).unwrap_or(&token)
    } else {
        &token
    };
    
    // æ­¥éª¤3: æ›´æ–°æ•°æ®åº“
    let (_, sqlite_path) = Self::get_cursor_paths()?;
    let conn = Connection::open(&sqlite_path)?;
    
    // å¼€å¯äº‹åŠ¡
    let tx = conn.transaction()?;
    
    // è®¤è¯ç±»å‹
    let auth_type_value = auth_type.unwrap_or_else(|| "Auth_0".to_string());
    
    // æ›´æ–°æ‰€æœ‰å¿…è¦å­—æ®µ
    let auth_fields = vec![
        ("cursorAuth/cachedEmail", &email),
        ("cursor.email", &email),
        ("cursorAuth/accessToken", processed_token),
        ("cursorAuth/refreshToken", processed_token),
        ("cursor.accessToken", processed_token),
        ("cursorAuth/cachedSignUpType", &auth_type_value),
    ];
    
    for (key, value) in auth_fields {
        tx.execute(
            "INSERT OR REPLACE INTO ItemTable (key, value) VALUES (?1, ?2)",
            params![key, value],
        )?;
        details.push(format!("æ›´æ–°å­—æ®µ: {}", key));
    }
    
    // æäº¤äº‹åŠ¡
    tx.commit()?;
    
    // æ­¥éª¤4: ç­‰å¾…æ•°æ®åº“å†™å…¥å®Œæˆ
    std::thread::sleep(std::time::Duration::from_millis(500));
    
    details.push("æ•°æ®åº“æ›´æ–°å®Œæˆ".to_string());
    details.push("è¯·æ‰‹åŠ¨é‡å¯ Cursor ä»¥åº”ç”¨æ›´æ”¹".to_string());
    
    Ok(SwitchAccountResult {
        success: true,
        message: "è´¦å·åˆ‡æ¢æˆåŠŸ".to_string(),
        details,
    })
}
```

### 3. å¼ºåˆ¶å…³é—­ Cursor è¿›ç¨‹

```rust
/// æ£€æµ‹ Cursor æ˜¯å¦åœ¨è¿è¡Œ
fn is_cursor_running() -> bool {
    #[cfg(target_os = "windows")]
    {
        let output = Command::new("tasklist")
            .args(&["/FI", "IMAGENAME eq Cursor.exe"])
            .output();
        
        if let Ok(output) = output {
            let stdout = String::from_utf8_lossy(&output.stdout);
            return stdout.contains("Cursor.exe");
        }
    }
    
    #[cfg(target_os = "macos")]
    {
        let output = Command::new("pgrep")
            .arg("-f")
            .arg("Cursor")
            .output();
        
        if let Ok(output) = output {
            return output.status.success();
        }
    }
    
    #[cfg(target_os = "linux")]
    {
        let output = Command::new("pgrep")
            .arg("-f")
            .arg("cursor")
            .output();
        
        if let Ok(output) = output {
            return output.status.success();
        }
    }
    
    false
}

/// å¼ºåˆ¶å…³é—­ Cursor è¿›ç¨‹
fn force_close_cursor() -> Result<()> {
    #[cfg(target_os = "windows")]
    {
        Command::new("taskkill")
            .args(&["/F", "/IM", "Cursor.exe"])
            .output()?;
    }
    
    #[cfg(target_os = "macos")]
    {
        Command::new("pkill")
            .arg("-f")
            .arg("Cursor")
            .output()?;
    }
    
    #[cfg(target_os = "linux")]
    {
        Command::new("pkill")
            .arg("-f")
            .arg("cursor")
            .output()?;
    }
    
    Ok(())
}
```

### 4. æ·»åŠ è´¦å·

```rust
pub fn add_account(
    email: String,
    token: String,
    refresh_token: Option<String>,
) -> Result<AccountInfo> {
    let account_file = Self::get_account_file_path()?;
    
    // è¯»å–ç°æœ‰è´¦å·
    let mut accounts = if account_file.exists() {
        let content = fs::read_to_string(&account_file)?;
        serde_json::from_str(&content).unwrap_or_else(|_| Vec::new())
    } else {
        Vec::new()
    };
    
    // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨
    if accounts.iter().any(|a: &AccountInfo| a.email == email) {
        return Err(anyhow!("è´¦å·å·²å­˜åœ¨"));
    }
    
    // åˆ›å»ºæ–°è´¦å·
    let new_account = AccountInfo {
        email: email.clone(),
        token: token.clone(),
        refresh_token,
        workos_cursor_session_token: None,
        is_current: false,
        created_at: chrono::Local::now().to_rfc3339(),
    };
    
    // æ·»åŠ åˆ°åˆ—è¡¨
    accounts.push(new_account.clone());
    
    // ä¿å­˜åˆ°æ–‡ä»¶
    let json = serde_json::to_string_pretty(&accounts)?;
    fs::write(&account_file, json)?;
    
    Ok(new_account)
}
```

### 5. é€€å‡ºç™»å½•

```rust
pub fn logout_account() -> Result<LogoutResult> {
    let mut details = Vec::new();
    
    // æ­¥éª¤1: å¼ºåˆ¶å…³é—­ Cursor
    if Self::is_cursor_running() {
        Self::force_close_cursor()?;
        details.push("å…³é—­ Cursor è¿›ç¨‹".to_string());
        std::thread::sleep(std::time::Duration::from_secs(2));
    }
    
    // æ­¥éª¤2: æ¸…é™¤æ•°æ®åº“ä¸­çš„è®¤è¯ä¿¡æ¯
    let (_, sqlite_path) = Self::get_cursor_paths()?;
    let conn = Connection::open(&sqlite_path)?;
    
    let tx = conn.transaction()?;
    
    // åˆ é™¤æ‰€æœ‰è®¤è¯ç›¸å…³å­—æ®µ
    let auth_keys = vec![
        "cursorAuth/cachedEmail",
        "cursorAuth/accessToken",
        "cursorAuth/refreshToken",
        "cursorAuth/cachedSignUpType",
        "cursor.email",
        "cursor.accessToken",
    ];
    
    for key in auth_keys {
        tx.execute("DELETE FROM ItemTable WHERE key = ?1", params![key])?;
        details.push(format!("æ¸…é™¤å­—æ®µ: {}", key));
    }
    
    tx.commit()?;
    
    // æ­¥éª¤3: æ›´æ–°è´¦å·åˆ—è¡¨
    let account_file = Self::get_account_file_path()?;
    if account_file.exists() {
        let content = fs::read_to_string(&account_file)?;
        let mut accounts: Vec<AccountInfo> = serde_json::from_str(&content)?;
        
        // å–æ¶ˆæ‰€æœ‰è´¦å·çš„å½“å‰æ ‡è®°
        for account in &mut accounts {
            account.is_current = false;
        }
        
        let json = serde_json::to_string_pretty(&accounts)?;
        fs::write(&account_file, json)?;
    }
    
    details.push("é€€å‡ºç™»å½•æˆåŠŸ".to_string());
    details.push("è¯·é‡å¯ Cursor".to_string());
    
    Ok(LogoutResult {
        success: true,
        message: "é€€å‡ºç™»å½•æˆåŠŸ".to_string(),
        details,
    })
}
```

## ğŸ¨ å‰ç«¯ç•Œé¢

### TokenManagePage ç»„ä»¶

```typescript
export const TokenManagePage: React.FC = () => {
  const [accounts, setAccounts] = useState<AccountInfo[]>([]);
  const [showQuickSwitch, setShowQuickSwitch] = useState(false);
  const [quickSwitchForm, setQuickSwitchForm] = useState({
    email: '',
    token: '',
    authType: 'Auth_0'
  });
  
  // åŠ è½½è´¦å·åˆ—è¡¨
  const loadAccounts = async () => {
    const result = await AccountService.listAccounts();
    setAccounts(result.accounts);
  };
  
  // å¿«é€Ÿåˆ‡æ¢
  const handleQuickSwitch = async () => {
    const result = await AccountService.switchAccountWithToken(
      quickSwitchForm.email,
      quickSwitchForm.token,
      quickSwitchForm.authType
    );
    
    if (result.success) {
      showToast('è´¦å·åˆ‡æ¢æˆåŠŸï¼Œè¯·é‡å¯ Cursor', 'success');
    }
  };
  
  // ä»åˆ—è¡¨åˆ‡æ¢
  const handleSwitchAccount = async (account: AccountInfo) => {
    const result = await AccountService.switchAccount(account.email);
    if (result.success) {
      showToast('è´¦å·åˆ‡æ¢æˆåŠŸ', 'success');
      loadAccounts();
    }
  };
  
  // åˆ é™¤è´¦å·
  const handleDeleteAccount = async (email: string) => {
    await AccountService.deleteAccount(email);
    loadAccounts();
  };
  
  return (
    <div className="space-y-6">
      {/* å¿«é€Ÿåˆ‡æ¢è¡¨å• */}
      <div className="bg-white rounded-lg shadow p-6">
        <h2 className="text-xl font-bold mb-4">ğŸš€ å¿«é€Ÿåˆ‡æ¢</h2>
        <input
          type="email"
          placeholder="é‚®ç®±åœ°å€"
          value={quickSwitchForm.email}
          onChange={(e) => setQuickSwitchForm({
            ...quickSwitchForm,
            email: e.target.value
          })}
        />
        <input
          type="text"
          placeholder="Token"
          value={quickSwitchForm.token}
          onChange={(e) => setQuickSwitchForm({
            ...quickSwitchForm,
            token: e.target.value
          })}
        />
        <select
          value={quickSwitchForm.authType}
          onChange={(e) => setQuickSwitchForm({
            ...quickSwitchForm,
            authType: e.target.value
          })}
        >
          <option value="Auth_0">Auth_0</option>
          <option value="Google">Google</option>
          <option value="GitHub">GitHub</option>
        </select>
        <button onClick={handleQuickSwitch}>
          ğŸš€ ç«‹å³åˆ‡æ¢
        </button>
      </div>
      
      {/* è´¦å·åˆ—è¡¨ */}
      <div className="bg-white rounded-lg shadow p-6">
        <h2 className="text-xl font-bold mb-4">ğŸ“‹ è´¦å·åˆ—è¡¨</h2>
        {accounts.map((account) => (
          <div key={account.email} className="border-b py-4">
            <div className="flex justify-between items-center">
              <div>
                <p className="font-medium">{account.email}</p>
                <p className="text-sm text-gray-500">
                  {account.is_current ? 'âœ… å½“å‰è´¦å·' : ''}
                </p>
              </div>
              <div className="space-x-2">
                <button onClick={() => handleSwitchAccount(account)}>
                  åˆ‡æ¢
                </button>
                <button onClick={() => handleDeleteAccount(account.email)}>
                  åˆ é™¤
                </button>
              </div>
            </div>
          </div>
        ))}
      </div>
    </div>
  );
};
```

## ğŸ” æ•…éšœæ’é™¤

### å¸¸è§é—®é¢˜

#### 1. åˆ‡æ¢åä»æ˜¾ç¤ºæœªç™»å½•

**åŸå› åˆ†æ**ï¼š
- Tokenæ ¼å¼ä¸æ­£ç¡®
- æ•°æ®åº“å­—æ®µæœªå…¨éƒ¨æ›´æ–°
- Cursorè¿›ç¨‹æœªå®Œå…¨å…³é—­

**è§£å†³æ–¹æ¡ˆ**ï¼š
```bash
# 1. æ£€æŸ¥Tokenæ ¼å¼
# æ­£ç¡®: eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9...
# é”™è¯¯: user_01XXX%3A%3AeyJhbGci...ï¼ˆéœ€è¦å¤„ç†ï¼‰

# 2. æ‰‹åŠ¨å…³é—­Cursor
# Windows
taskkill /F /IM Cursor.exe

# macOS/Linux
pkill -f Cursor

# 3. æ£€æŸ¥æ•°æ®åº“
sqlite3 state.vscdb "SELECT key, value FROM ItemTable WHERE key LIKE '%cursor%'"
```

#### 2. ERROR_NOT_LOGGED_IN é”™è¯¯

**åŸå› **ï¼š
- `cursorAuth/cachedEmail` å­—æ®µæœªæ›´æ–°
- Cursorç¼“å­˜äº†æ—§çš„è®¤è¯çŠ¶æ€

**è§£å†³æ–¹æ¡ˆ**ï¼š
1. ç¡®ä¿å¼ºåˆ¶å…³é—­äº†Cursorè¿›ç¨‹
2. æ£€æŸ¥æ‰€æœ‰å¿…è¦å­—æ®µæ˜¯å¦å·²æ›´æ–°
3. ç­‰å¾…500msåå†é‡å¯Cursor
4. æ¸…é™¤Cursorç¼“å­˜ï¼ˆå¯é€‰ï¼‰

#### 3. RefreshToken é—®é¢˜

**é‡è¦å‘ç°**ï¼š
- RefreshToken å®é™…ä¸Šå°±æ˜¯ AccessToken
- ä¸¤è€…å­˜å‚¨ç›¸åŒçš„JWTå€¼
- ä¸éœ€è¦å•ç‹¬è·å–RefreshToken

```rust
// æ­£ç¡®åšæ³•
let token = "eyJhbGci...";
update_field("cursorAuth/accessToken", token);
update_field("cursorAuth/refreshToken", token);  // ç›¸åŒå€¼
```

## âš™ï¸ é…ç½®é€‰é¡¹

### è®¤è¯ç±»å‹

| ç±»å‹ | è¯´æ˜ | ä½¿ç”¨åœºæ™¯ |
|------|------|----------|
| Auth_0 | é»˜è®¤è®¤è¯ | é‚®ç®±å¯†ç æ³¨å†Œ |
| Google | Googleè´¦å· | Googleç™»å½• |
| GitHub | GitHubè´¦å· | GitHubç™»å½• |

### Tokenæ ¼å¼

```
å®Œæ•´æ ¼å¼: user_01XXXXXXX%3A%3AeyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9...
ç®€åŒ–æ ¼å¼: user_01XXXXXXX::eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9...
çº¯JWT:    eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9...
```

## ğŸ“Š ä½¿ç”¨æµç¨‹å›¾

```
ç”¨æˆ·æ“ä½œ
   â†“
è¾“å…¥é‚®ç®±å’ŒToken
   â†“
æ£€æµ‹Cursorè¿›ç¨‹ â”€â”€â†’ è¿è¡Œä¸­? â”€â”€â†’ å¼ºåˆ¶å…³é—­
   â†“                          â†“
å¤„ç†Tokenæ ¼å¼              ç­‰å¾…2ç§’
   â†“                          â†“
æ›´æ–°æ•°æ®åº“å­—æ®µ â†â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   â†“
ç­‰å¾…500ms
   â†“
æç¤ºé‡å¯Cursor
   â†“
ç”¨æˆ·æ‰‹åŠ¨é‡å¯
   â†“
åŠ è½½æ–°è®¤è¯ä¿¡æ¯
   â†“
ç™»å½•æˆåŠŸ âœ…
```

## âš ï¸ é‡è¦æç¤º

1. **å¿…é¡»å…³é—­Cursor**ï¼šåˆ‡æ¢å‰å¿…é¡»å¼ºåˆ¶å…³é—­Cursorè¿›ç¨‹
2. **æ‰‹åŠ¨é‡å¯**ï¼šåˆ‡æ¢åéœ€è¦æ‰‹åŠ¨é‡å¯Cursor
3. **Tokenæ ¼å¼**ï¼šç¡®ä¿Tokenæ ¼å¼æ­£ç¡®ï¼ˆçº¯JWTï¼‰
4. **ç­‰å¾…æ—¶é—´**ï¼šæ•°æ®åº“æ›´æ–°åç­‰å¾…500ms
5. **å¤‡ä»½æ•°æ®**ï¼šæ“ä½œå‰å»ºè®®å¤‡ä»½æ•°æ®åº“

---

**æœ€åæ›´æ–°**ï¼š2025-10-28
**æ–‡æ¡£ç‰ˆæœ¬**ï¼š1.0.0

