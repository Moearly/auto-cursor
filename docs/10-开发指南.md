# 10 - 开发指南

## 📋 开发规范

本文档介绍 Auto-Cursor 项目的开发规范、最佳实践和贡献指南。

## 🎯 代码规范

### 1. Rust 代码规范

#### 命名规范
```rust
// 模块名：小写蛇形命名
mod machine_id;
mod account_manager;

// 结构体：大驼峰命名
struct MachineIdRestorer;
struct AccountInfo;

// 函数：小写蛇形命名
fn generate_new_machine_ids() -> Result<MachineIds>;
fn switch_account_with_token() -> Result<SwitchAccountResult>;

// 常量：大写蛇形命名
const MAX_RETRY_COUNT: u32 = 3;
const DEFAULT_TIMEOUT: Duration = Duration::from_secs(30);

// 枚举：大驼峰命名
enum AuthType {
    Auth0,
    Google,
    GitHub,
}
```

#### 代码格式化
```bash
# 使用 rustfmt 格式化代码
cargo fmt

# 检查格式
cargo fmt -- --check

# 配置 rustfmt.toml
max_width = 100
tab_spaces = 4
edition = "2024"
```

#### 代码检查
```bash
# 使用 clippy 检查代码质量
cargo clippy

# 严格模式
cargo clippy -- -D warnings

# 修复可自动修复的问题
cargo clippy --fix
```

#### 文档注释
```rust
/// 生成新的机器ID
///
/// # Returns
///
/// 返回包含所有机器ID的结构体
///
/// # Errors
///
/// 如果生成随机数失败，返回错误
///
/// # Examples
///
/// ```
/// let restorer = MachineIdRestorer::new()?;
/// let ids = restorer.generate_new_machine_ids()?;
/// println!("Generated ID: {}", ids.dev_device_id);
/// ```
pub fn generate_new_machine_ids(&self) -> Result<MachineIds> {
    // 实现
}
```

### 2. TypeScript 代码规范

#### 命名规范
```typescript
// 接口：大驼峰命名，I 前缀（可选）
interface UserAuthInfo {
  isAuthorized: boolean;
  tokenLength: number;
}

// 类型别名：大驼峰命名
type UpdateInfo = {
  hasUpdate: boolean;
  version: string;
};

// 类：大驼峰命名
class CursorService {
  // ...
}

// 函数：小驼峰命名
function checkCursorInstallation(): Promise<boolean> {
  // ...
}

// 常量：大写蛇形命名
const MAX_RETRY_COUNT = 3;
const DEFAULT_TIMEOUT = 30000;

// 变量：小驼峰命名
const authInfo = await checkAuth();
const usageData = await getUsageStats();
```

#### 代码格式化
```bash
# 使用 prettier 格式化
npx prettier --write "src/**/*.{ts,tsx}"

# 配置 .prettierrc
{
  "semi": true,
  "trailingComma": "es5",
  "singleQuote": false,
  "printWidth": 100,
  "tabWidth": 2
}
```

#### ESLint 配置
```json
{
  "extends": [
    "eslint:recommended",
    "plugin:@typescript-eslint/recommended",
    "plugin:react/recommended",
    "plugin:react-hooks/recommended"
  ],
  "rules": {
    "no-console": "warn",
    "@typescript-eslint/explicit-module-boundary-types": "off",
    "react/react-in-jsx-scope": "off"
  }
}
```

### 3. Git 提交规范

#### Commit Message 格式
```
<type>(<scope>): <subject>

<body>

<footer>
```

#### Type 类型
- `feat`: 新功能
- `fix`: 修复bug
- `docs`: 文档更新
- `style`: 代码格式调整
- `refactor`: 重构
- `perf`: 性能优化
- `test`: 测试相关
- `chore`: 构建/工具相关

#### 示例
```bash
# 新功能
git commit -m "feat(auth): 添加快速切换账号功能"

# 修复bug
git commit -m "fix(machine-id): 修复Windows路径识别问题"

# 文档更新
git commit -m "docs: 更新部署指南"

# 重构
git commit -m "refactor(account): 优化账号切换逻辑"
```

## 🏗️ 项目结构

### 添加新功能

#### 1. 后端新增 Tauri 命令

```rust
// 1. 在对应模块中实现功能
// src-tauri/src/new_feature.rs
pub fn new_feature_function(param: String) -> Result<String> {
    // 实现逻辑
    Ok("success".to_string())
}

// 2. 在 lib.rs 中创建 Tauri 命令
#[tauri::command]
async fn new_feature_command(param: String) -> Result<String, String> {
    new_feature_function(param)
        .map_err(|e| e.to_string())
}

// 3. 注册命令
pub fn run() {
    tauri::Builder::default()
        .invoke_handler(tauri::generate_handler![
            // ... 其他命令
            new_feature_command,  // 添加新命令
        ])
        .run(tauri::generate_context!())
        .expect("error while running tauri application");
}
```

#### 2. 前端调用新命令

```typescript
// 1. 在 services 中创建服务方法
// src/services/newFeatureService.ts
import { invoke } from '@tauri-apps/api/core';

export class NewFeatureService {
  static async callNewFeature(param: string): Promise<string> {
    return await invoke<string>('new_feature_command', { param });
  }
}

// 2. 在组件中使用
import { NewFeatureService } from '../services/newFeatureService';

const handleClick = async () => {
  try {
    const result = await NewFeatureService.callNewFeature('test');
    console.log('结果:', result);
  } catch (error) {
    console.error('错误:', error);
  }
};
```

#### 3. 添加新页面

```typescript
// 1. 创建页面组件
// src/pages/NewFeaturePage.tsx
import React, { useState } from 'react';

export const NewFeaturePage: React.FC = () => {
  const [data, setData] = useState<string>('');

  return (
    <div className="space-y-6">
      <h1 className="text-2xl font-bold">新功能</h1>
      {/* 页面内容 */}
    </div>
  );
};

// 2. 在 App.tsx 中添加路由
import { NewFeaturePage } from './pages/NewFeaturePage';

<Routes>
  {/* ... 其他路由 */}
  <Route path="/new-feature" element={<NewFeaturePage />} />
</Routes>

// 3. 在 Layout.tsx 中添加导航
const navItems = [
  // ... 其他导航
  { path: '/new-feature', label: '新功能', icon: '🆕' },
];
```

## 🧪 测试

### 1. Rust 单元测试

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_generate_machine_ids() {
        let restorer = MachineIdRestorer::new().unwrap();
        let ids = restorer.generate_new_machine_ids().unwrap();
        
        // 验证 UUID 格式
        assert!(ids.dev_device_id.contains('-'));
        assert_eq!(ids.dev_device_id.len(), 36);
        
        // 验证 SHA256 长度
        assert_eq!(ids.machine_id.len(), 64);
        
        // 验证 SHA512 长度
        assert_eq!(ids.mac_machine_id.len(), 128);
    }

    #[test]
    fn test_token_processing() {
        let token = "user_01XXX%3A%3AeyJhbGci...";
        let processed = process_token(token);
        assert!(processed.starts_with("eyJhbGci"));
    }
}
```

运行测试：
```bash
# 运行所有测试
cargo test

# 运行特定测试
cargo test test_generate_machine_ids

# 显示输出
cargo test -- --nocapture
```

### 2. TypeScript 测试

```typescript
// 使用 Vitest
import { describe, it, expect } from 'vitest';
import { CursorService } from '../services/cursorService';

describe('CursorService', () => {
  it('should check cursor installation', async () => {
    const result = await CursorService.checkCursorInstallation();
    expect(typeof result).toBe('boolean');
  });

  it('should get cursor paths', async () => {
    const paths = await CursorService.getCursorPaths();
    expect(Array.isArray(paths)).toBe(true);
    expect(paths.length).toBe(2);
  });
});
```

运行测试：
```bash
# 运行测试
pnpm test

# 监听模式
pnpm test:watch

# 覆盖率
pnpm test:coverage
```

## 🔧 调试技巧

### 1. Rust 调试

#### 使用 println! 调试
```rust
fn debug_function() {
    println!("调试信息: {:?}", some_variable);
    eprintln!("错误信息: {:?}", error);
}
```

#### 使用日志宏
```rust
use crate::{log_info, log_debug, log_error};

fn function_with_logging() {
    log_info!("开始执行");
    log_debug!("变量值: {:?}", variable);
    log_error!("发生错误: {}", error);
}
```

#### 使用 dbg! 宏
```rust
fn debug_with_dbg() {
    let result = dbg!(complex_calculation());
    dbg!(&some_struct);
}
```

### 2. TypeScript 调试

#### 浏览器开发者工具
```typescript
// 在代码中设置断点
debugger;

// 使用 console
console.log('普通日志');
console.error('错误日志');
console.table(arrayData);
console.group('分组日志');
console.groupEnd();
```

#### VS Code 调试配置
```json
// .vscode/launch.json
{
  "version": "0.2.0",
  "configurations": [
    {
      "type": "node",
      "request": "launch",
      "name": "Tauri Dev",
      "runtimeExecutable": "pnpm",
      "runtimeArgs": ["tauri", "dev"],
      "console": "integratedTerminal"
    }
  ]
}
```

## 📊 性能优化

### 1. Rust 性能优化

#### 使用 Release 模式
```bash
# 开发模式（慢但有调试信息）
cargo build

# Release 模式（快但无调试信息）
cargo build --release
```

#### 性能分析
```bash
# 使用 cargo-flamegraph
cargo install flamegraph
cargo flamegraph --bin auto-cursor

# 使用 perf (Linux)
perf record --call-graph dwarf ./target/release/auto-cursor
perf report
```

#### 避免不必要的克隆
```rust
// 不好
fn process(data: String) {
    // data 被移动
}
let s = String::from("test");
process(s.clone());  // 不必要的克隆

// 好
fn process(data: &str) {
    // 借用
}
let s = String::from("test");
process(&s);  // 借用，无克隆
```

### 2. TypeScript 性能优化

#### 使用 React.memo
```typescript
const ExpensiveComponent = React.memo(({ data }) => {
  // 只在 data 改变时重新渲染
  return <div>{data}</div>;
});
```

#### 使用 useMemo 和 useCallback
```typescript
const MemoizedComponent: React.FC = () => {
  // 缓存计算结果
  const expensiveValue = useMemo(() => {
    return computeExpensiveValue(a, b);
  }, [a, b]);

  // 缓存函数
  const handleClick = useCallback(() => {
    doSomething(a);
  }, [a]);

  return <div onClick={handleClick}>{expensiveValue}</div>;
};
```

#### 虚拟滚动
```typescript
import { FixedSizeList } from 'react-window';

<FixedSizeList
  height={600}
  itemCount={1000}
  itemSize={50}
  width="100%"
>
  {({ index, style }) => (
    <div style={style}>Item {index}</div>
  )}
</FixedSizeList>
```

## 🔐 安全最佳实践

### 1. 输入验证

```rust
// Rust 端验证
fn validate_email(email: &str) -> Result<()> {
    let email_regex = Regex::new(r"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$")?;
    if !email_regex.is_match(email) {
        return Err(anyhow!("无效的邮箱地址"));
    }
    Ok(())
}

fn validate_token(token: &str) -> Result<()> {
    if token.len() < 100 {
        return Err(anyhow!("Token长度不足"));
    }
    if !token.starts_with("eyJ") {
        return Err(anyhow!("无效的Token格式"));
    }
    Ok(())
}
```

```typescript
// TypeScript 端验证
function validateEmail(email: string): boolean {
  const regex = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/;
  return regex.test(email);
}

function validateToken(token: string): boolean {
  return token.length >= 100 && token.startsWith('eyJ');
}
```

### 2. 错误处理

```rust
// 不要暴露敏感信息
fn handle_error(error: Error) -> String {
    // 不好：暴露内部路径
    format!("Error: {}", error)
    
    // 好：通用错误信息
    "操作失败，请重试".to_string()
}
```

### 3. 权限检查

```rust
fn require_admin() -> Result<()> {
    #[cfg(target_os = "windows")]
    {
        if !is_elevated() {
            return Err(anyhow!("需要管理员权限"));
        }
    }
    Ok(())
}
```

## 📝 文档编写

### 1. 代码注释

```rust
// 单行注释：解释为什么这样做
// 使用 %3A%3A 分隔符是因为 Cursor API 返回的格式

/// 文档注释：解释函数的作用
/// 
/// 这个函数会处理 Token 字符串，移除用户ID前缀
```

### 2. README 更新

每次添加新功能时，更新 README.md：
- 功能列表
- 使用示例
- 配置说明

### 3. 变更日志

维护 CHANGELOG.md：
```markdown
## [0.8.0] - 2025-10-28

### Added
- 添加快速切换账号功能
- 支持批量注册

### Fixed
- 修复 Windows 路径识别问题
- 修复 Token 格式处理bug

### Changed
- 优化账号切换流程
- 改进错误提示信息
```

## 🤝 贡献流程

### 1. Fork 项目

```bash
# Fork 项目到你的账号
# 克隆你的 fork
git clone https://github.com/your-username/auto-cursor.git
cd auto-cursor

# 添加上游仓库
git remote add upstream https://github.com/original/auto-cursor.git
```

### 2. 创建分支

```bash
# 创建功能分支
git checkout -b feature/new-feature

# 或修复分支
git checkout -b fix/bug-description
```

### 3. 开发和测试

```bash
# 开发功能
# 编写代码...

# 运行测试
cargo test
pnpm test

# 格式化代码
cargo fmt
npx prettier --write "src/**/*.{ts,tsx}"

# 代码检查
cargo clippy
pnpm lint
```

### 4. 提交更改

```bash
# 添加更改
git add .

# 提交（遵循提交规范）
git commit -m "feat: 添加新功能"

# 推送到你的 fork
git push origin feature/new-feature
```

### 5. 创建 Pull Request

1. 在 GitHub 上打开你的 fork
2. 点击 "New Pull Request"
3. 填写 PR 描述：
   - 功能说明
   - 测试情况
   - 相关 Issue

### 6. 代码审查

- 响应审查意见
- 进行必要的修改
- 更新 PR

## 📋 检查清单

### 开发前
- [ ] 了解项目结构
- [ ] 阅读相关文档
- [ ] 配置开发环境
- [ ] 运行项目确保正常

### 开发中
- [ ] 遵循代码规范
- [ ] 编写清晰的注释
- [ ] 实现功能逻辑
- [ ] 处理错误情况
- [ ] 编写单元测试

### 提交前
- [ ] 运行所有测试
- [ ] 格式化代码
- [ ] 代码检查通过
- [ ] 更新文档
- [ ] 编写提交信息

### PR 前
- [ ] 同步上游更新
- [ ] 解决冲突
- [ ] 本地测试通过
- [ ] 填写 PR 描述
- [ ] 关联相关 Issue

## 🔗 有用的资源

### 官方文档
- [Tauri 文档](https://tauri.app/)
- [Rust 文档](https://doc.rust-lang.org/)
- [React 文档](https://react.dev/)
- [TypeScript 文档](https://www.typescriptlang.org/)

### 学习资源
- [Rust Book](https://doc.rust-lang.org/book/)
- [Tauri 示例](https://github.com/tauri-apps/tauri/tree/dev/examples)
- [React 教程](https://react.dev/learn)

### 工具
- [Rust Playground](https://play.rust-lang.org/)
- [TypeScript Playground](https://www.typescriptlang.org/play)
- [Regex101](https://regex101.com/)

---

**最后更新**：2025-10-28
**文档版本**：1.0.0

