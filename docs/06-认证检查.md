# 06 - 认证检查

## 📋 功能概述

认证检查模块负责查询 Cursor 的登录状态、账户信息和使用统计，通过调用 Cursor API 获取详细的使用数据。

## 🎯 核心功能

### 1. 认证状态检查
- ✅ 检查是否已登录
- ✅ 验证Token有效性
- ✅ 获取账户基本信息
- ✅ 查询订阅状态

### 2. 使用统计
- ✅ Token使用量查询
- ✅ 模型调用统计
- ✅ 聚合使用数据
- ✅ 成本计算

### 3. 用户分析
- ✅ 每日活跃度
- ✅ 代码接受率
- ✅ Composer请求数
- ✅ Agent请求数

## 🗂️ 数据结构

### UserAuthInfo 结构

```rust
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UserAuthInfo {
    pub is_authorized: bool,              // 是否已授权
    pub token_length: usize,              // Token长度
    pub token_valid: bool,                // Token是否有效
    pub api_status: Option<u16>,          // API状态码
    pub error_message: Option<String>,    // 错误信息
    pub checksum: Option<String>,         // Token校验和
    pub account_info: Option<AccountInfo>,// 账户信息
}
```

### AccountInfo 结构

```rust
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AccountInfo {
    pub email: Option<String>,                      // 邮箱
    pub username: Option<String>,                   // 用户名
    pub subscription_type: Option<String>,          // 订阅类型
    pub subscription_status: Option<String>,        // 订阅状态
    pub trial_days_remaining: Option<i32>,          // 试用剩余天数
    pub usage_info: Option<String>,                 // 使用信息
    pub aggregated_usage: Option<AggregatedUsageData>, // 聚合使用数据
}
```

### AggregatedUsageData 结构

```rust
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AggregatedUsageData {
    pub aggregations: Vec<ModelUsage>,      // 模型使用列表
    pub total_input_tokens: String,         // 总输入Token
    pub total_output_tokens: String,        // 总输出Token
    pub total_cache_write_tokens: String,   // 总缓存写入Token
    pub total_cache_read_tokens: String,    // 总缓存读取Token
    pub total_cost_cents: f64,              // 总成本（美分）
}
```

### ModelUsage 结构

```rust
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ModelUsage {
    pub model_intent: String,           // 模型用途
    pub input_tokens: String,           // 输入Token
    pub output_tokens: String,          // 输出Token
    pub cache_write_tokens: String,     // 缓存写入Token
    pub cache_read_tokens: String,      // 缓存读取Token
    pub total_cents: f64,               // 成本（美分）
}
```

## 🔧 核心实现

### 1. 检查认证状态

```rust
#[tauri::command]
pub async fn check_cursor_auth() -> Result<UserAuthInfo, String> {
    log_info!("🔍 开始检查 Cursor 认证状态...");
    
    // 获取数据库路径
    let (_, sqlite_path) = get_cursor_paths()
        .map_err(|e| format!("获取Cursor路径失败: {}", e))?;
    
    // 打开数据库连接
    let conn = Connection::open(&sqlite_path)
        .map_err(|e| format!("打开数据库失败: {}", e))?;
    
    // 查询Token
    let token_result: Result<String, rusqlite::Error> = conn.query_row(
        "SELECT value FROM ItemTable WHERE key = 'cursorAuth/accessToken'",
        [],
        |row| row.get(0),
    );
    
    match token_result {
        Ok(token) => {
            log_info!("✅ 找到Token，长度: {}", token.len());
            
            // 验证Token
            let auth_info = verify_token_with_api(&token).await?;
            
            Ok(auth_info)
        }
        Err(_) => {
            log_warn!("❌ 未找到Token");
            Ok(UserAuthInfo {
                is_authorized: false,
                token_length: 0,
                token_valid: false,
                api_status: None,
                error_message: Some("未找到认证Token".to_string()),
                checksum: None,
                account_info: None,
            })
        }
    }
}
```

### 2. 验证Token并获取账户信息

```rust
async fn verify_token_with_api(token: &str) -> Result<UserAuthInfo, String> {
    // 创建HTTP客户端
    let client = reqwest::Client::new();
    
    // 调用认证API
    let response = client
        .get("https://api.cursor.sh/api/auth/status")
        .header("Authorization", format!("Bearer {}", token))
        .send()
        .await
        .map_err(|e| format!("API请求失败: {}", e))?;
    
    let status_code = response.status().as_u16();
    
    if status_code == 200 {
        // 解析响应
        let auth_data: serde_json::Value = response.json().await
            .map_err(|e| format!("解析响应失败: {}", e))?;
        
        // 提取账户信息
        let account_info = AccountInfo {
            email: auth_data["email"].as_str().map(String::from),
            username: auth_data["username"].as_str().map(String::from),
            subscription_type: auth_data["subscription"]["type"].as_str().map(String::from),
            subscription_status: auth_data["subscription"]["status"].as_str().map(String::from),
            trial_days_remaining: auth_data["trial_days_remaining"].as_i64().map(|v| v as i32),
            usage_info: None,
            aggregated_usage: None,
        };
        
        Ok(UserAuthInfo {
            is_authorized: true,
            token_length: token.len(),
            token_valid: true,
            api_status: Some(status_code),
            error_message: None,
            checksum: Some(calculate_token_checksum(token)),
            account_info: Some(account_info),
        })
    } else {
        Ok(UserAuthInfo {
            is_authorized: false,
            token_length: token.len(),
            token_valid: false,
            api_status: Some(status_code),
            error_message: Some(format!("API返回错误: {}", status_code)),
            checksum: Some(calculate_token_checksum(token)),
            account_info: None,
        })
    }
}
```

### 3. 获取使用统计

```rust
#[tauri::command]
pub async fn get_usage_stats(
    start_date: Option<u64>,
    end_date: Option<u64>,
) -> Result<AggregatedUsageData, String> {
    log_info!("📊 获取使用统计...");
    
    // 获取Token
    let token = get_token_from_db()?;
    
    // 设置时间范围（默认最近30天）
    let end = end_date.unwrap_or_else(|| {
        SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .unwrap()
            .as_secs()
    });
    
    let start = start_date.unwrap_or(end - 30 * 24 * 60 * 60);
    
    // 创建HTTP客户端
    let client = reqwest::Client::new();
    
    // 构建请求体
    let request_body = serde_json::json!({
        "start_date": start,
        "end_date": end,
        "team_id": 0
    });
    
    // 调用使用统计API
    let response = client
        .post("https://api.cursor.sh/api/usage")
        .header("Authorization", format!("Bearer {}", token))
        .json(&request_body)
        .send()
        .await
        .map_err(|e| format!("API请求失败: {}", e))?;
    
    if response.status().is_success() {
        let usage_data: AggregatedUsageData = response.json().await
            .map_err(|e| format!("解析响应失败: {}", e))?;
        
        log_info!("✅ 使用统计获取成功");
        Ok(usage_data)
    } else {
        Err(format!("获取使用统计失败: {}", response.status()))
    }
}
```

### 4. 获取聚合使用数据

```rust
#[tauri::command]
pub async fn get_aggregated_usage(
    start_date: Option<u64>,
    end_date: Option<u64>,
) -> Result<AggregatedUsageData, String> {
    log_info!("📈 获取聚合使用数据...");
    
    let token = get_token_from_db()?;
    
    // 设置时间范围
    let end = end_date.unwrap_or_else(|| {
        SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .unwrap()
            .as_secs()
    });
    
    let start = start_date.unwrap_or(end - 30 * 24 * 60 * 60);
    
    let client = reqwest::Client::new();
    
    // 调用聚合API
    let response = client
        .get("https://api.cursor.sh/api/usage/aggregated")
        .header("Authorization", format!("Bearer {}", token))
        .query(&[
            ("start_date", start.to_string()),
            ("end_date", end.to_string()),
        ])
        .send()
        .await
        .map_err(|e| format!("API请求失败: {}", e))?;
    
    if response.status().is_success() {
        let usage_data: AggregatedUsageData = response.json().await
            .map_err(|e| format!("解析响应失败: {}", e))?;
        
        // 计算总计
        let total_input: u64 = usage_data.aggregations.iter()
            .filter_map(|m| m.input_tokens.parse::<u64>().ok())
            .sum();
        
        let total_output: u64 = usage_data.aggregations.iter()
            .filter_map(|m| m.output_tokens.parse::<u64>().ok())
            .sum();
        
        let total_cost: f64 = usage_data.aggregations.iter()
            .map(|m| m.total_cents)
            .sum();
        
        log_info!("✅ 聚合数据获取成功");
        log_info!("📊 总输入Token: {}", total_input);
        log_info!("📊 总输出Token: {}", total_output);
        log_info!("💰 总成本: ${:.2}", total_cost / 100.0);
        
        Ok(usage_data)
    } else {
        Err(format!("获取聚合数据失败: {}", response.status()))
    }
}
```

### 5. 获取用户分析数据

```rust
#[tauri::command]
pub async fn get_user_analytics(
    start_date: Option<String>,
    end_date: Option<String>,
) -> Result<UserAnalyticsData, String> {
    log_info!("📊 获取用户分析数据...");
    
    let token = get_token_from_db()?;
    
    // 设置日期范围
    let end = end_date.unwrap_or_else(|| {
        chrono::Local::now().format("%Y-%m-%d").to_string()
    });
    
    let start = start_date.unwrap_or_else(|| {
        (chrono::Local::now() - chrono::Duration::days(30))
            .format("%Y-%m-%d")
            .to_string()
    });
    
    let client = reqwest::Client::new();
    
    // 调用分析API
    let response = client
        .get("https://api.cursor.sh/api/user-analytics")
        .header("Authorization", format!("Bearer {}", token))
        .query(&[
            ("start_date", start),
            ("end_date", end),
        ])
        .send()
        .await
        .map_err(|e| format!("API请求失败: {}", e))?;
    
    if response.status().is_success() {
        let analytics_data: UserAnalyticsData = response.json().await
            .map_err(|e| format!("解析响应失败: {}", e))?;
        
        log_info!("✅ 用户分析数据获取成功");
        Ok(analytics_data)
    } else {
        Err(format!("获取分析数据失败: {}", response.status()))
    }
}
```

## 📊 API 端点

### 1. 认证状态
```
GET https://api.cursor.sh/api/auth/status
Headers:
  Authorization: Bearer <token>

Response:
{
  "email": "user@example.com",
  "username": "username",
  "subscription": {
    "type": "pro",
    "status": "active"
  },
  "trial_days_remaining": 14
}
```

### 2. 使用统计
```
POST https://api.cursor.sh/api/usage
Headers:
  Authorization: Bearer <token>
Body:
{
  "start_date": 1698768000,
  "end_date": 1701360000,
  "team_id": 0
}

Response:
{
  "aggregations": [
    {
      "model_intent": "chat",
      "input_tokens": "1000000",
      "output_tokens": "500000",
      "cache_write_tokens": "100000",
      "cache_read_tokens": "50000",
      "total_cents": 25.50
    }
  ],
  "total_input_tokens": "1000000",
  "total_output_tokens": "500000",
  "total_cache_write_tokens": "100000",
  "total_cache_read_tokens": "50000",
  "total_cost_cents": 25.50
}
```

### 3. 聚合使用数据
```
GET https://api.cursor.sh/api/usage/aggregated
Headers:
  Authorization: Bearer <token>
Query:
  start_date: 1698768000
  end_date: 1701360000

Response: (同上)
```

### 4. 用户分析
```
GET https://api.cursor.sh/api/user-analytics
Headers:
  Authorization: Bearer <token>
Query:
  start_date: 2025-10-01
  end_date: 2025-10-28

Response:
{
  "dailyMetrics": [
    {
      "date": "2025-10-28",
      "activeUsers": 1,
      "acceptedLinesAdded": 1250,
      "acceptedLinesDeleted": 350,
      "totalApplies": 45,
      "totalAccepts": 38,
      "totalTabsShown": 120,
      "totalTabsAccepted": 95,
      "composerRequests": 25,
      "agentRequests": 10
    }
  ],
  "period": {
    "start": "2025-10-01",
    "end": "2025-10-28"
  },
  "totalMembersInTeam": 1
}
```

## 🎨 前端界面

### AuthCheckPage 组件

```typescript
export const AuthCheckPage: React.FC = () => {
  const [authInfo, setAuthInfo] = useState<UserAuthInfo | null>(null);
  const [usageData, setUsageData] = useState<AggregatedUsageData | null>(null);
  const [loading, setLoading] = useState(false);
  
  // 检查认证状态
  const checkAuth = async () => {
    setLoading(true);
    try {
      const result = await invoke<UserAuthInfo>('check_cursor_auth');
      setAuthInfo(result);
      
      if (result.is_authorized) {
        // 获取使用统计
        const usage = await invoke<AggregatedUsageData>('get_aggregated_usage');
        setUsageData(usage);
      }
    } catch (error) {
      console.error('检查认证失败:', error);
    } finally {
      setLoading(false);
    }
  };
  
  return (
    <div className="space-y-6">
      {/* 认证状态卡片 */}
      <div className="bg-white rounded-lg shadow p-6">
        <h2 className="text-xl font-bold mb-4">🔐 认证状态</h2>
        
        {authInfo && (
          <div className="space-y-2">
            <div className="flex items-center">
              <span className={authInfo.is_authorized ? 'text-green-500' : 'text-red-500'}>
                {authInfo.is_authorized ? '✅ 已登录' : '❌ 未登录'}
              </span>
            </div>
            
            {authInfo.account_info && (
              <>
                <p><strong>邮箱:</strong> {authInfo.account_info.email}</p>
                <p><strong>订阅类型:</strong> {authInfo.account_info.subscription_type}</p>
                <p><strong>订阅状态:</strong> {authInfo.account_info.subscription_status}</p>
                {authInfo.account_info.trial_days_remaining && (
                  <p><strong>试用剩余:</strong> {authInfo.account_info.trial_days_remaining} 天</p>
                )}
              </>
            )}
          </div>
        )}
        
        <button onClick={checkAuth} disabled={loading}>
          {loading ? '检查中...' : '检查认证状态'}
        </button>
      </div>
      
      {/* 使用统计卡片 */}
      {usageData && (
        <div className="bg-white rounded-lg shadow p-6">
          <h2 className="text-xl font-bold mb-4">📊 使用统计</h2>
          
          <div className="grid grid-cols-2 gap-4 mb-6">
            <div className="bg-blue-50 p-4 rounded">
              <p className="text-sm text-gray-600">总输入Token</p>
              <p className="text-2xl font-bold">{usageData.total_input_tokens}</p>
            </div>
            
            <div className="bg-green-50 p-4 rounded">
              <p className="text-sm text-gray-600">总输出Token</p>
              <p className="text-2xl font-bold">{usageData.total_output_tokens}</p>
            </div>
            
            <div className="bg-purple-50 p-4 rounded">
              <p className="text-sm text-gray-600">缓存写入</p>
              <p className="text-2xl font-bold">{usageData.total_cache_write_tokens}</p>
            </div>
            
            <div className="bg-orange-50 p-4 rounded">
              <p className="text-sm text-gray-600">总成本</p>
              <p className="text-2xl font-bold">${(usageData.total_cost_cents / 100).toFixed(2)}</p>
            </div>
          </div>
          
          {/* 模型使用详情 */}
          <h3 className="font-bold mb-2">模型使用详情</h3>
          <div className="space-y-2">
            {usageData.aggregations.map((model, index) => (
              <div key={index} className="border-b pb-2">
                <p className="font-medium">{model.model_intent}</p>
                <div className="grid grid-cols-4 gap-2 text-sm text-gray-600">
                  <div>输入: {model.input_tokens}</div>
                  <div>输出: {model.output_tokens}</div>
                  <div>缓存: {model.cache_write_tokens}</div>
                  <div>成本: ${(model.total_cents / 100).toFixed(2)}</div>
                </div>
              </div>
            ))}
          </div>
        </div>
      )}
    </div>
  );
};
```

## 🔍 故障排除

### 常见问题

#### 1. Token未找到

**症状**：提示"未找到认证Token"

**解决方案**：
```bash
# 检查数据库
sqlite3 state.vscdb "SELECT key, value FROM ItemTable WHERE key LIKE '%token%'"

# 确认是否已登录Cursor
```

#### 2. API请求失败

**症状**：返回401或403错误

**原因**：
- Token已过期
- Token格式不正确
- 网络连接问题

**解决方案**：
- 重新登录Cursor
- 检查Token格式
- 检查网络连接

#### 3. 使用统计为空

**症状**：返回空数据

**原因**：
- 时间范围内无使用记录
- API参数错误

**解决方案**：
- 调整时间范围
- 检查API参数

## 📈 数据可视化

### 使用趋势图

```typescript
import { Line } from 'react-chartjs-2';

const UsageChart: React.FC<{ data: DailyMetric[] }> = ({ data }) => {
  const chartData = {
    labels: data.map(d => d.date),
    datasets: [
      {
        label: 'Composer请求',
        data: data.map(d => d.composerRequests || 0),
        borderColor: 'rgb(75, 192, 192)',
        tension: 0.1
      },
      {
        label: 'Agent请求',
        data: data.map(d => d.agentRequests || 0),
        borderColor: 'rgb(255, 99, 132)',
        tension: 0.1
      }
    ]
  };
  
  return <Line data={chartData} />;
};
```

## ⚠️ 注意事项

1. **Token安全**：不要泄露Token
2. **API限制**：注意API调用频率
3. **数据隐私**：妥善保管使用数据
4. **时区问题**：注意时间范围的时区转换

---

**最后更新**：2025-10-28
**文档版本**：1.0.0

